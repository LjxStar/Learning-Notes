# 一、绪论
## 1.1 基本概念
**数据结构**：相互之间存在一种或多种特定关系的数据元素的集合。
**数据元素**：数据的==基本单位==，在计算机处理和程序设计中通常被作为一个
整体进行考虑和处理。
**逻辑结构**：指数据结构中==数据元素之间的逻辑关系==。它与数据的存储无关，
是独立于计算机的。
**物理结构**：数据的逻辑结构==在计算机内存中的存储方式==，又称存储结构。
**抽象数据类型**：指一个数学模型以及定义在该模型上的一组操作。具体包
括三部分：==数据对象==、数据对象上==关系==的集合和对数据对象的==基本操作==的集合。
**算法**：对特定问题求解步骤的一种描述，是指令的有限序列，其中每一条指令表
示一个或多个操作。 

## 1.2 数据结构的三大要素
### 1.2.1 逻辑关系
**线性结构**：结构中的数据元素之间只存在==一对一==的关系，除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。
**树形结构**：结构中数据元素之间存在==一对多==的关系（例如：思维导图）。
**图状结构**：数据元素之间是==多对多==的关系（例如：道路）。
**集合结构**：结构中的数据元素之间除“==同属一个集合==”外，别==无其它关系==（例如：一群羊）。

### 1.2.2 物理结构
**顺序存储**：把逻辑上相邻的元素存储==在物理位置也相邻==的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
**链式存储**：逻辑上相邻的元素在物理位置上==可以不相邻==，借助指向元素存储地址的指针来表示元素之间的逻辑关系。
**索引存储**：在存储元素信息的同时，还==建立附加的索引表==，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。
**散列存储**：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。

### 1.2.3 数据的运算
***数据上的运算**包括**运算的定义和实现**。*
*运算的**定义**是针对逻辑结构的，指出运算的功能。*
*运算的**实现**是针对存储结构的，指出运算的具体操作步骤。*

## 1.3 复杂度分析
### 1.3.1 迭代
**迭代（iteration）** 是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

**1.for循环**
`for` 循环是最常见的迭代形式之一，**适合在预先知道迭代次数时使用**。`
```java
/* for 循环 */
int forLoop(int n) {
    int res = 0;
    // 循环求和 1, 2, ..., n-1, n
    for (int i = 1; i <= n; i++) {
        res += i;
    }
    return res;
}
```
**2.while循环**
与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在 `while` 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。
```java
`/* while 循环 */
int whileLoop(int n) {
    int res = 0;
    int i = 1; // 初始化条件变量
    // 循环求和 1, 2, ..., n-1, n
    while (i <= n) {
        res += i;
        i++; // 更新条件变量
    }
    return res;
}
```
**3.嵌套循环**

### 1.3.2 递归
**递归（recursion）** 是一种算法策略，通过函数调用自身来解决问题。
**[经典的递归问题及其实现](https://www.cnblogs.com/gshao/p/9535687.html)**

对于1+2+···+n的计算，可调用recur(n)函数：
```c
/* 递归 */
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```
**1.调用栈**
递归函数每次调用自身时，系统都会为新开启的函数**分配内存**，以存储局部变量、调用地址和其他信息等。
![[递归的栈调用.png]]**2.   尾递归**
**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为**尾递归（tail recursion）**。
```c
/* 尾递归 */
int tailRecur(int n, int res) {
    // 终止条件
    if (n == 0)
        return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
```
**3.递归树**
在函数内递归调用了两个函数，**这意味着从一个调用产生了两个调用分支**。这样不断递归调用下去，最终将产生一棵层数为n的**递归树（recursion tree）**。
```c
/* 斐波那契数列：递归 */
int fib(int n) {
    // 终止条件 f(1) = 0, f(2) = 1
    if (n == 1 || n == 2)
        return n - 1;
    // 递归调用 f(n) = f(n-1) + f(n-2)
    int res = fib(n - 1) + fib(n - 2);
    // 返回结果 f(n)
    return res;
}
```

### 1.3.3 时间复杂度
**时间复杂度**统计的不是算法运行时间，而是算法运行时间**随着数据量变大时的增长趋势**。

**1.分析技巧**
![[时间复杂度的简化技巧.png]]
![[时间复杂度决定阶项.png]]

**2.常见类型**
![[常见类型的时间复杂度比较.png]]
![[常见类型的时间复杂度比较曲线图.png]]

**3.最差、平均和最佳时间复杂度**

### 1.3.4 空间复杂度
**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然**。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。

# 二、线性表
## 2.1 线性表的定义
**线性表**为n(n>=0) 个数据元素的有限序列。记为
$$L=(a_1,a_2,\cdots,a_i,\cdots,a_n)$$
其中L为表名，a为表中的元素，称为**结点**或记录。n是表中元素的个数，称为表长。当n=0时，称为空表。  
线性表中的第一个元素称为**表头（head）**，最后一个元素称为**表尾（tail）。** 除第一个元素外，每个元素有且仅有一个**直接前驱。** 除最后一个元素外，每个元素有且仅有一个**直接后继。**

## 2.2 顺序表
**顺序表**是一种线性表的存储结构，通过连续的存储空间实现**逻辑上相邻**的元素在**物理位置上也相邻。** 
### 2.2.1 静态分配
**1.数据结构**
```c
#define MaxSize 1024

typedef int etype;
typedef struct SequentList{
	etype* data;
	int length;
	int capacity;
} arr;
```
**2.初始化顺序表**
```c
arr* init() {
	if (capacity <= 0) {
		printf("数组容量不能为0");
		return NULL;
	}

	arr* L = (arr*)malloc(sizeof(arr));
	if (L == NULL) {
		printf("内存分配失败!");
		return NULL;
	}
	L -> data = (etype*)calloc(capacity, sizeof(etype));
	if (L->data == NULL) {
		printf("内存分配失败!");
		free(L);
		return NULL;
	}

	L->length = 0;
	L->capacity = MaxSize;
	return L;
}
```
**3.销毁顺序表**
```c
void destroy(arr* p) {
	free(p->data);
	free(p);	
}
```
**4.插入节点**
```c
int insert(arr* p, etype d, int i) {
	int len = length(p);
	if (len >= p->capacity) {
		printf("数组容量不足！\n");
		return 0;
	}

	if (i < 0 || i > len) {
		printf("索引%d输入错误！\n", i);
		return -1;
	}

	for (int j = len; j > i; j--) {
		p->data[j] = p->data[j - 1];
	}
	p->data[i] = d;
	p->length = len + 1;
	return 1;
}
```
**5.删除节点
```c
int remove(arr* p, int i, etype* res) {
	int len = length(p);
	if (len == 0) {
		printf("数组长度为0\n");
		return 0;
	}
	if (i < 0) {
		i += len;
	}
	if (i < 0 || i > len - 1) {
		printf("索引%d输入错误！\n", i);
		return -1;
	}

	if (res != NULL) {
		*res = p->data[i];
	}

	for (int j = i; j < len - 1; j++) {
		p->data[j] = p->data[j+1];
	}
	p->length = len - 1;
	return 1;
}
```
**6.修改节点**
```c
int set(arr* p, etype d, int i) {
	int len = length(p);
	if (len == 0) {
		printf("数组长度为0\n");
		return 0;
	}
	if (i < 0) {
		i += len;
	}
	if (i < 0 || i > len - 1) {
		printf("索引%d输入错误！\n", i);
		return -1;
	}
	p->data[i] = d;
	return 1;
}
```
**7.按索引查找操作**
```c
int get(arr* p, int i, etype *res) {
	int len = length(p);
	if (len == 0) {
		printf("数组长度为0\n");
		return 0;
	}
	if (i < 0) {
		i += len;
	}
	if (i < 0 || i > len - 1) {
		printf("索引%d输入错误！\n", i);
		return -1;
	}
	
	*res = p->data[i];
	return 1;
}
```
**8.按值查找操作**
```c
int indexOf(arr* p, etype d, int last) {
	int len = length(p);
	if (last) {
		for (int i = len - 1; i >= 0; i--) {
			if (p->data[i] == d) {
				return i;
			}
		}
	}
	else {
		for (int i = 0; i < len; i++) {
			if (p->data[i] == d) {
				return i;
			}
		}
	}
	return -1;
}
```
**9.是否包含某值**
```c
int contains(arr* p, etype d) {
	if (indexOf(p, d, 0) == -1) {
		return 0;
	}
	return 1;
}
```
### 2.2.2* 动态分配

## 2.3 链表
### 2.3.1 常见链表类型
**1.单向链表**：即前面介绍的普通链表。单向链表的**节点包含值**和指向下一节点的**引用**两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 `NULL` 。
**2.循环链表**：是一种特殊的单链表，又称环形链表，其尾结点指向首结点，形成一个环。可以带头结点，也可以不带头结点。若带头结点，遍历到头节点的时候需要跳过。
**3.双向链表**：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向**后继节点**（下一个节点）和**前驱节点**（上一个节点）的引用。

> [!NOTE] 链表的应用
> **单向链表**通常用于实现栈、队列、哈希表和图等数据结构。
> - **栈与队列**：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。
> - **哈希表**：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。
> - **图**：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。
> 
> **双向链表**常用于需要快速查找前一个和后一个元素的场景。
> 
> - **高级数据结构**：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。
> - **浏览器历史**：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。
> - **LRU 算法**：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。
> 
> **环形链表**常用于需要周期性操作的场景，比如操作系统的资源调度。
> 
> - **时间片轮转调度算法**：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。
> - **数据缓冲区**：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。

### 2.3.2 单链表
**单链表**是一种链式存储结构，由一系列结点组成。每个结点包括两部分：数据域`data`和指针域`link`。**数据域存储数据元素，指针域存储下一个结点的地址**。 链表中的最后一个节点没有后继，其指针域为`NULL`。其基本操作的代码实现如下：

**1.数据结构**
```c
typedef int etype;
typedef struct Node{
	etype data;
	struct Node* next;
} Node;
typedef struct Linkedlist{
	Node* head;
	int size;
} list;
```
**2.初始化链表**
```c
list* init() {
	list* L = (list*)malloc(sizeof(list));
	if (L == NULL) {
		printf("内存分配失败!");
		return NULL;
	}

	Node* head = (Node*)malloc(sizeof(Node));
	if (head == NULL) {
		printf("内存分配失败!");
		free(L);
		return NULL;
	}
	
	head->next = NULL;
	L->head = head;
	L->size = 0;
	return L;
}
```
**3.销毁链表**
```c
void destroy(list* p) {
	Node* cur = p->head;
	while (cur != NULL) {
		Node* next = cur->next;
		free(cur);
		cur = next;
	}
	free(p);
}
```
**4.插入节点**
```c
int insert(list* p, etype d, int i) {
    int sz = size(p);
	if (i == -1) {
		i = sz;
	}
	if (i < 0 || i > sz) {
		printf("索引%d输入错误！\n", i);
		return 0; 
	}
	
	Node* newNode = (Node*)malloc(sizeof(Node));
	if (newNode == NULL) {
		printf("内存分配失败!");
		return -1;
	}
	newNode->data = d;
	
	Node* cur = p->head;
	for (int j = 0; j < i; j++) {
		cur = cur->next;
		 
	}
	
	newNode->next = cur->next;
	cur->next = newNode;
	p->size = sz + 1;	
	return 1;
}
```
**5.删除节点**
```c
int delElm(list* p, int i, etype* res) {
	int sz = size(p);
	if (sz == 0) {
		printf("链表长度为0");
		return 0; 
	}
	if (i < 0) {
		i += sz;
	}
	if (i < 0 || i > sz - 1) {
		printf("索引%d输入错误！\n", i);
		return 0;
	}
	
	Node* cur = p -> head;
	for (int j = 0; j < i; j++) {
		cur = cur -> next;
	}
	
	Node* removedNode = cur -> next;
	if (res != NULL) {
		*res = removedNode -> data;
	} 
	
	cur -> next = removedNode -> next;
	free(removedNode);
	removedNode = NULL;
	p -> size = sz - 1;
	return 1;
}
```
**6.修改节点**
```c
int set(list* p, etype d, int i) {
	int sz = size(p);
	if (sz == 0) {
		printf("数组长度为0\n");
		return 0;
	}
	if (i < 0) {
		i += sz;
	}
	if (i < 0 || i > sz - 1) {
		printf("索引%d输入错误！\n", i);
		return -1;
	}
	
	Node* cur = p -> head -> next;
	for (int j = 0; j < i; j++) {
		cur = cur -> next;
	}
	
	cur -> data = d;
	return 1;
}
```
**7.按索引查找**
```c
int get(list* p, int i, etype* res) {
	if (p == NULL || res == NULL) return 0;
	int sz = size(p);
	if (sz == 0) {
		printf("链表长度为0\n");
		return 0;
	}
	if (i < 0) {
		i += sz;
	}
	if (i < 0 || i > sz - 1) {
		printf("索引%d输入错误！\n", i);
		return 0;
	}

	Node* cur = p->head->next;
	for (int j = 0; j < i; j++) {
		cur = cur->next;
	}
	*res = cur->data;
	return 1;
}
```
**8.按值查找**
```c
int indexOf(list* p, etype d, int last) {
	if (p == NULL) return -1;
	int found_index = -1;
	int current_index = 0;
	Node* cur = p->head->next;

	while (cur != NULL) {
		if (cur->data == d) {
			if (last == 0) { // 从前往后找，找到第一个就返回
				return current_index;
			} else { // 从后往前找，记录最后一个匹配的索引
				found_index = current_index;
			}
		}
		cur = cur->next;
		current_index++;
	}

	return found_index; // 如果last=1，返回最后一个找到的索引；如果没找到，返回-1
}
```
**9.是否包含**
```c
int contains(list* p, etype d) {
	if (p == NULL) return 0;
	Node* cur = p->head->next;
	while (cur != NULL) {
		if (cur->data == d) {
			return 1; // 找到了
		}
		cur = cur->next;
	}
	return 0; // 没找到
}
```

### 2.3.3* 双向链表
## 2.4 顺序表与链表的对比

|  维度  |       顺序表       |    链表     |
| :--: | :-------------: | :-------: |
| 存储方式 |     连续内存空间      |  分散内存空间   |
| 容量扩展 |      长度不可变      |   可灵活扩展   |
| 内存效率 | 元素占用内存少，但可能浪费空间 |  元素占用内存多  |
| 访问元素 |      O(1)       | O(1)~O(n) |
| 添加元素 |    O(1)~O(n)    |   O(1)    |
| 删除元素 |    O(1)~O(n)    |   O(1)    |

## 2.5 线性表推广
### 2.5.1 数组
**数组**是具有**相同类型**的数据元素的集合。对于数组元素i的地址*LOC(i)*，则有
$$
LOC(0) = a (i = 0)
$$
$$

LOC(i-1)+L = a + i * L (i> 0)
$$
数组可以是**多维**的，并且存储数据元素的内存单元地址是**一维**的，因此，在存储数组结构之前，需要将多维关系**映射**到一维关系的问题。


> [!NOTE] 数组的应用
> **数组**是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。
> - **随机访问**：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。
> - **排序和搜索**：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。
> - **查找表**：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。
> - **机器学习**：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。
> - **数据结构实现**：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。

#### 2.5.1.1 不同语言下的数组实现
**1.c**
```c
/* 初始化数组 */
int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }
int nums[5] = { 1, 3, 2, 5, 4 };
```
**2.cpp** 
```cpp
/* 初始化数组 */
// 存储在栈上
int arr[5];
int nums[5] = { 1, 3, 2, 5, 4 };
// 存储在堆上（需要手动释放空间）
int* arr1 = new int[5];
int* nums1 = new int[5] { 1, 3, 2, 5, 4 };
```
**3.python**
```python
# 初始化数组
arr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]
nums: list[int] = [1, 3, 2, 5, 4]
```
**4.java**
```java
/* 初始化数组 */
int[] arr = new int[5]; // { 0, 0, 0, 0, 0 }
int[] nums = { 1, 3, 2, 5, 4 };
```

#### 2.5.1.2 特殊矩阵的压缩
若**多个数据元素的值都相同**，则只分配一个元素值得存储空间，且**零元素不占存储空间**。
**1.对称矩阵**
![[对称矩阵.png]]
**2.三角矩阵**
![[三角矩阵.png]]
**3.对角矩阵**
![[对角矩阵的特点.png]]
![[对角矩阵的存储.png]]

#### 2.5.1.2 稀疏矩阵
设在m * n的矩阵中有 t 个非零元素。矩阵的稀疏因子为
$$
δ=t/(m*n)
$$
当δ≤0.05时称为稀疏矩阵，又称**稀疏数组**。对于这类矩阵，非零元素的分布是随机的，所以在存储非零元素值的同时，还应存储它所在的行号和列号，于是通过三元组的方法进行存储。

**1.数据结构的定义**
```c
// 三元组结构体，用于存储一个非零元素
typedef struct {
    int row;    // 行号
    int col;    // 列号
    int value;  // 值
} Triple;

// 稀疏矩阵结构体
#define MAX_SIZE 100 // 假设非零元素最多有100个

typedef struct {
    int rows;           // 矩阵的总行数
    int cols;           // 矩阵的总列数
    int num_terms;      // 非零元素的个数
    Triple data[MAX_SIZE]; // 存储非零元素的三元组数组
} SparseMatrix;
```
**2.普通数组转化为稀疏数组**
```c
// 从一个普通的二维数组创建稀疏矩阵
void convertToSparseMatrix(int r, int c, int normalMatrix[][c], SparseMatrix *s) {
    s->rows = r;
    s->cols = c;
    s->num_terms = 0;

    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            if (normalMatrix[i][j] != 0) {
                if (s->num_terms >= MAX_SIZE) {
                    printf("非零元素数量超过最大容量.\n");
                    return;
                }
                s->data[s->num_terms].row = i;
                s->data[s->num_terms].col = j;
                s->data[s->num_terms].value = normalMatrix[i][j];
                s->num_terms++;
            }
        }
    }
}
```
*编译器需要知道列的大小，才能正确计算内存地址，从而访问到数组中的每一个元素，因此createSparseMatrix函数通过**可变长数组**的形式传递normalMatrix的列*
**3.打印稀疏数组**
```c
// 打印稀疏矩阵（以二维数组的形式）
void printSparseMatrix(const SparseMatrix *s) {
    printf("Sparse Matrix (%d x %d):\n", s->rows, s->cols);
    for (int i = 0; i < s->rows; i++) {
        for (int j = 0; j < s->cols; j++) {
            int found = 0;
            // 在三元组数组中查找当前位置的值
            for (int k = 0; k < s->num_terms; k++) {
                if (s->data[k].row == i && s->data[k].col == j) {
                    printf("%d\t", s->data[k].value);
                    found = 1;
                    break;
                }
            }
            // 如果没找到，说明是0
            if (!found) {
                printf("0\t");
            }
        }
        printf("\n");
    }
}
```
**4*.稀疏数组的转置**
对于稀疏矩阵，我们**不能简单地交换行列号**，因为三元组数组需要保持**行优先**的顺序。
```c
// 稀疏矩阵的快速转置
void transposeSparseMatrix(const SparseMatrix *s, SparseMatrix *t) {
    t->rows = s->cols;
    t->cols = s->rows;
    t->num_terms = s->num_terms;

    if (s->num_terms > 0) {
        // 1. 统计原矩阵每一列的非零元素个数
        int *row_terms = (int *)malloc(s->cols * sizeof(int));
        for (int i = 0; i < s->cols; i++) {
            row_terms[i] = 0;
        }
        for (int i = 0; i < s->num_terms; i++) {
            row_terms[s->data[i].col]++;
        }

        // 2. 计算转置后矩阵每一行的起始位置
        int *starting_pos = (int *)malloc(s->cols * sizeof(int));
        starting_pos[0] = 0;
        for (int i = 1; i < s->cols; i++) {
            starting_pos[i] = starting_pos[i - 1] + row_terms[i - 1];
        }

        // 3. 执行转置
        for (int i = 0; i < s->num_terms; i++) {
            int j = s->data[i].col; // 原列号
            int pos = starting_pos[j]; // 在转置后数组中的位置

            t->data[pos].row = s->data[i].col;
            t->data[pos].col = s->data[i].row;
            t->data[pos].value = s->data[i].value;

            starting_pos[j]++; // 更新该行的起始位置，为下一个元素做准备
        }

        free(row_terms);
        free(starting_pos);
    }
}
```
**5*.稀疏数组转化为普通数组**
```c
#include <string.h> // 需要包含 string.h 以使用 memset

int** convertToNormal(const SparseMatrix *s) {
    // 1. 分配行指针数组
    int **normalMatrix = (int **)malloc(s->rows * sizeof(int *));
    if (normalMatrix == NULL) {
        printf("行指针的内存分配失败.\n");
        return NULL;
    }

    // 2. 为每一行分配内存，并初始化为0
    for (int i = 0; i < s->rows; i++) {
        normalMatrix[i] = (int *)malloc(s->cols * sizeof(int));
        if (normalMatrix[i] == NULL) {
            printf("行的内存分配失败.\n");
            // 如果某一行分配失败，需要释放之前已经分配的所有行
            for (int j = 0; j < i; j++) {
                free(normalMatrix[j]);
            }
            free(normalMatrix);
            return NULL;
        }
        // 使用 memset 高效地将该行所有元素初始化为0
        memset(normalMatrix[i], 0, s->cols * sizeof(int));
    }

    // 3. 遍历稀疏矩阵的三元组，填充非零值
    for (int i = 0; i < s->num_terms; i++) {
        int r = s->data[i].row;
        int c = s->data[i].col;
        int v = s->data[i].value;
        normalMatrix[r][c] = v;
    }

    return normalMatrix;
}
```
稀疏数组的存储方式除了**三元组顺序表**外，还可以采取**十字链表**的形式存储。

#### 2.5.1.3* 动态数组的扩容机制

### 2.5.2 广义表
#### 2.5.2.1 广义表的定义
![[广义表的定义.png]]
#### 2.5.2.1 广义表的性质
1.广义表中的数据元素**有相对次序**：一个直接前驱和直接后继，表头无前驱，表尾无后继。
2.广义表的**长度**定义为**最外层所包含元素的个数**。==如：C=(a, (b, c)）是长度为2的广义表。==
3.广义表的**深度**定义为该广义表展开后**所包含括号的重数**。==如：A = (b, c)的深度为1，B=(A, d)的深度为2，C = (f, B, h)的深度为3。*注意：原子的深度为0，空表的深度为1.*==
4.广义表可以**为其他广义表共享**；==如上：广义表B就共享表A。==
5.广义表**可以是一个递归的表**。==如：F=(a,F)。*注意：递归表的深度是无穷值，长度是有限值.*==
6.广义表**是多层次结构**，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表。
### 2.5.3* 字符串
#### 2.5.3.1 基于数组的字符串实现
#### 2.5.3.2 匹配算法
**1.朴素的模式匹配算法BF**
**2.KMP模式匹配算法**
# 三、栈与队列

## 3.1 栈
**栈（stack）** 是一种遵循**先入后出**逻辑的线性数据结构。堆叠元素的顶部称为“**栈顶**”，底部称为“**栈底**”。将把元素添加到栈顶的操作叫作“**入栈**”，删除栈顶元素的操作叫作“**出栈**”。
![[栈的图示.png]]

> [!NOTE] 栈的应用
> **浏览器中的后退与前进、软件中的撤销与反撤销**。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。
> **程序内存管理**。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。


### 3.1.1 基于数组的栈
使用**数组**实现栈时，我们可以将数组的尾部作为栈顶。*入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为O(1)。*
```c
#include<stdio.h>
#include<stdlib.h>

//顺序栈
//数据结构定义
typedef int etype;
typedef struct ArrayStack{
	etype* data;
	int top;
	int capacity;
} stack;

//函数声明
stack* init(int capacity); //初始化栈
void destroy(stack* p); //销毁栈，释放内存
int length(stack* p); //返回栈的长度
void show(stack* p); //遍历栈，从栈底到栈顶依次打印元素
int isEmpty(stack* p); //判断栈是否为空，空返回1，否则返回0
int isFull(stack* p); //判断栈是否已满，满返回1，否则返回0
int push(stack* p, etype d); //将元素d入栈，若栈满则返回0，否则返回1
int pop(stack* p, etype* res = NULL); //将栈顶元素出栈，若栈空则返回0，否则通过res返回该值并返回1
int peek(stack* p, etype* res); //获取栈顶元素，若栈空则返回0，否则通过res返回该值并返回1
stack* reverse(stack* p, int inplace = 0); 
//将栈p的元素顺序入栈到新栈中，若inplace=1则原地倒置，若inplace=0则非原地倒置，返回新栈指针，若失败返回NULL
//int reverse(stack* from, stack** to); //将栈from的元素顺序入栈到to中，若成功返回1，否则返回0

//栈的初始化
stack* init(int capacity) {
	if (capacity <= 0) {
		printf("栈容量不能为0");
		return NULL;
	}

	stack* L = (stack*)malloc(sizeof(stack));
	if (L == NULL) {
		printf("内存分配失败!");
		return NULL;
	}
	L -> data = (etype*)calloc(capacity, sizeof(etype));
	if (L->data == NULL) {
		printf("内存分配失败!");
		free(L);
		return NULL;
	}
	
	L->top = -1;
	L->capacity = capacity;
	return L; 
} 

//销毁栈
void destroy(stack* p) {
	free(p->data);
	free(p);
}

//返回栈的长度
int length(stack* p) {
	return p->top+1;
}

int isEmpty(stack* p) {
	return length(p) == 0;
}

int isFull(stack* p) {
	return length(p) == p->capacity;
}

//遍历
void show(stack* p) {
	int len = length(p);
	if (len == 0) {
		printf("栈长度为0\n");
		return;
	}
	int cur;
	printf("[");
	for (int i = 0; i < len - 1; i++) {
		cur = p->data[i];
		printf("%d,", cur); 
	}
	printf("%d", p->data[len - 1]);
	printf("]\n");
	return;
}

//入栈
int push(stack* p, etype d) {
	if (isFull(p)) {
		printf("栈容量不足！\n");
		return 0; 
	}
	p->data[++p->top] = d;
	return 1;
}

//出栈
int pop(stack* p, etype* res) {
	if (isEmpty(p)) {
		printf("数组长度为0\n");
		return 0;
	}
	
	if (res != NULL) {
		*res = p->data[p->top];
	}
	p->top = p->top - 1;
	return 1;
}

//返回栈顶
int peek(stack* p, etype* res) {
	if (isEmpty(p)) {
		printf("数组长度为0\n");
		return 0;
	}
	
	*res = p->data[p->top];
	return 1;
}

//倒置
stack* reverse(stack* p, int inplace) {
	if (p == NULL) {
		return NULL;
	}

	if (inplace) {
		// 原地倒置
		int left = 0;          
		int right = p->top;   
		while (left < right) {
			int temp = p->data[left];
			p->data[left] = p->data[right];
			p->data[right] = temp;

			left++;
			right--;
		}

		// 返回被修改后的原栈
		return p; 
	}
	else {
		//非原地倒置
		stack* reversed_stack = init(p->capacity);
		if (reversed_stack == NULL) {
			printf("内存分配失败，无法创建新栈。\n");
			return NULL;
		}

		for (int i = p->top; i >= 0; i--) {
			push(reversed_stack, p->data[i]);
		}

		// 返回新创建的栈
		return reversed_stack; 
	}
}
```

### 3.1.2 基于链表的链栈
使用**链表**实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。*添加元素与删除元素的时间复杂度都为O(1)。*
```c
/* 基于数组实现的栈 */
typedef struct {
    int *data;
    int size;
} ArrayStack;

/* 构造函数 */
ArrayStack *newArrayStack() {
    ArrayStack *stack = malloc(sizeof(ArrayStack));
    // 初始化一个大容量，避免扩容
    stack->data = malloc(sizeof(int) * MAX_SIZE);
    stack->size = 0;
    return stack;
}

/* 析构函数 */
void delArrayStack(ArrayStack *stack) {
    free(stack->data);
    free(stack);
}

/* 获取栈的长度 */
int size(ArrayStack *stack) {
    return stack->size;
}

/* 判断栈是否为空 */
bool isEmpty(ArrayStack *stack) {
    return stack->size == 0;
}

/* 入栈 */
void push(ArrayStack *stack, int num) {
    if (stack->size == MAX_SIZE) {
        printf("栈已满\n");
        return;
    }
    stack->data[stack->size] = num;
    stack->size++;
}

/* 访问栈顶元素 */
int peek(ArrayStack *stack) {
    if (stack->size == 0) {
        printf("栈为空\n");
        return INT_MAX;
    }
    return stack->data[stack->size - 1];
}

/* 出栈 */
int pop(ArrayStack *stack) {
    int val = peek(stack);
    stack->size--;
    return val;
}
```

## 3.2 队列
队列（queue）是一种遵循**先入先出**规则的线性数据结构。队列头部称为“**队首**”，尾部称为“**队尾**”，将把元素加入队尾的操作称为“**入队**”，删除队首元素的操作称为“**出队**”。
![[队列的图示.png]]

> [!NOTE] 队列的应用
> **淘宝订单**。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。
> **各类待办事项**。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。


### 3.2.1 基于循环数组的队列

定义一个变量 `front` 指**向队首元素的索引**，并维护一个变量 `size` **用于记录队列长度**。定义 `rear = front + size` ，这个公式计算出的 `rear` **指向队尾元素之后的下一个位置**。
在不断进行入队和出队的过程中，`front` 和 `rear` 都在向右移动，**当它们到达数组尾部时就无法继续移动了**。我们需要让 `front` 或 `rear` 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“**取余操作**”来实现。
```c
/* 基于环形数组实现的队列 */
typedef struct {
    int *nums;       // 用于存储队列元素的数组
    int front;       // 队首指针，指向队首元素
    int queSize;     // 尾指针，指向队尾 + 1
    int queCapacity; // 队列容量
} ArrayQueue;

/* 构造函数 */
ArrayQueue *newArrayQueue(int capacity) {
    ArrayQueue *queue = (ArrayQueue *)malloc(sizeof(ArrayQueue));
    // 初始化数组
    queue->queCapacity = capacity;
    queue->nums = (int *)malloc(sizeof(int) * queue->queCapacity);
    queue->front = queue->queSize = 0;
    return queue;
}

/* 析构函数 */
void delArrayQueue(ArrayQueue *queue) {
    free(queue->nums);
    free(queue);
}

/* 获取队列的容量 */
int capacity(ArrayQueue *queue) {
    return queue->queCapacity;
}

/* 获取队列的长度 */
int size(ArrayQueue *queue) {
    return queue->queSize;
}

/* 判断队列是否为空 */
bool empty(ArrayQueue *queue) {
    return queue->queSize == 0;
}

/* 访问队首元素 */
int peek(ArrayQueue *queue) {
    assert(size(queue) != 0);
    return queue->nums[queue->front];
}

/* 入队 */
void push(ArrayQueue *queue, int num) {
    if (size(queue) == capacity(queue)) {
        printf("队列已满\r\n");
        return;
    }
    // 计算队尾指针，指向队尾索引 + 1
    // 通过取余操作实现 rear 越过数组尾部后回到头部
    int rear = (queue->front + queue->queSize) % queue->queCapacity;
    // 将 num 添加至队尾
    queue->nums[rear] = num;
    queue->queSize++;
}

/* 出队 */
int pop(ArrayQueue *queue) {
    int num = peek(queue);
    // 队首指针向后移动一位，若越过尾部，则返回到数组头部
    queue->front = (queue->front + 1) % queue->queCapacity;
    queue->queSize--;
    return num;
}

/* 返回数组用于打印 */
int *toArray(ArrayQueue *queue, int *queSize) {
    *queSize = queue->queSize;
    int *res = (int *)calloc(queue->queSize, sizeof(int));
    int j = queue->front;
    for (int i = 0; i < queue->queSize; i++) {
        res[i] = queue->nums[j % queue->queCapacity];
        j++;
    }
    return res;
}
```

==**如果不维护 `queSize` 变量，仅使用 `front` 和 `rear` 指针**==

|  操作  |                            代码                            |
| :--: | :------------------------------------------------------: |
| 判断空  |              `queue->front == queue->rear`               |
| 判断满  | `(queue->rear + 1) % queue->queCapacity == queue->front` |
| 计算长度 |          `(rear - front + capacity) % capacity`          |

```cpp
typedef struct {
    int *nums;       // 用于存储队列元素的数组
    int front;       // 队首指针，指向队首元素
    int rear;        // 队尾指针，指向队尾元素的下一个位置
    int queCapacity; // 队列容量
} ArrayQueue;

//cpp
/* 判断队列是否为空 */
bool empty(ArrayQueue *queue) {
    // 当 front 和 rear 相等时，队列为空
    return queue->front == queue->rear;
}

/* 判断队列是否已满 */
bool full(ArrayQueue *queue) {
    // 当 rear 的下一个位置是 front 时，队列已满
    return (queue->rear + 1) % queue->queCapacity == queue->front;
}

/* 获取队列的长度 */
int size(ArrayQueue *queue) {
    // 核心公式：通过取模运算处理环形情况
    // (rear - front + capacity) % capacity
    // 这个公式在队空时返回0，在非空时返回正确长度
    return (queue->rear - queue->front + queue->queCapacity) % queue->queCapacity;
}

/* 入队 */
void push(ArrayQueue *queue, int num) {
    if (full(queue)) {
        printf("队列已满，无法入队 %d\n", num);
        return;
    }
    // 将 num 添加至队尾
    queue->nums[queue->rear] = num;
    // 队尾指针向后移动一位，若越过尾部，则返回到数组头部
    queue->rear = (queue->rear + 1) % queue->queCapacity;
}

/* 出队 */
int pop(ArrayQueue *queue) {
    int num = peek(queue); // 访问队首元素
    // 队首指针向后移动一位，若越过尾部，则返回到数组头部
    queue->front = (queue->front + 1) % queue->queCapacity;
    return num;
}
```

### 3.2.2 带头尾节点的链表队列
我们可以将链表的“**头节点**”和“**尾节点**”分别视为“**队首**”和“**队尾**”，规定**队尾仅可添加节点**，**队首仅可删除节点**。
```c
#include<stdio.h>
#include<stdlib.h>

//带头尾节点的链表队列
//数据结构定义
typedef int etype;
typedef struct Node{
	etype data;
	struct Node* next;
} Node;
typedef struct LinkedlistQueue{
	Node* head;
	Node* tail;
	int size;
} queue;

//函数声明
queue* init(); //初始化队列
void destroy(queue* p); //销毁队列，释放内存
int size(queue* p); //返回队列长度
void show(queue* p); //遍历队列
int isEmpty(queue* p); //判断队列是否为空，空返回1，否则返回0
int push(queue* p, etype d); //将元素d入队，若内存分配失败返回0，否则返回1
int pop(queue* p, etype* res = NULL); //将队头元素出队，若队列空则返回0，否则通过res返回该值并返回1
int peek(queue* p, etype* res); //获取队头元素，若队列空则返回0，否则通过res返回该值并返回1


//偶数入队,奇数出队,输出0结束 
void processQueue(queue* q) {
    etype value;
    printf("请输入多个整数:\n");
    while(1) {
        scanf("%d", &value);
        if(value == 0) break;
        
        if(value % 2 == 0) { // 偶数入队
            push(q, value);
            printf("%d(偶数)入队后队列: ", value);
            show(q);
        } else { // 奇数出队
            if(pop(q, &value)) {
                printf("%d(奇数)出队成功，队列: ", value);
                show(q);
            } else {
                printf("队列为空，无法出队\n");
            }
        }
    }
}

//队列的初始化
queue* init() {
	queue* L = (queue*)malloc(sizeof(queue));
	if (L == NULL) {
		printf("内存分配失败!");
		return NULL;
	}
	
	Node* tempNode = (Node*)malloc(sizeof(Node));
	if (tempNode == NULL) {
		printf("内存分配失败!");
		free(L);
		return NULL;
	}
	
	
	tempNode->next = NULL;
	L->head = tempNode, L->tail = tempNode;
	L->size = 0;
	return L;
} 

//销毁队列
void destroy(queue* p) {
	Node* cur = p->head;
	while (cur != NULL) {
		Node* next = cur->next;
		free(cur);
		cur = next;
	}
	free(p);
}

//返回队列的大小
int size(queue* p) {
	return p->size;
}

//遍历
void show(queue* p) {
	int sz = size(p);
	if (sz == 0) {
		printf("队列长度为0\n");
		return;
	}
	Node* cur = p->head->next;
	while (cur != NULL) {
		printf("%d ", cur->data);
		cur = cur->next;
	}
	printf("\n");
}

int isEmpty(queue* p) {
	return size(p) == 0;
}

//入队
int push(queue* p, etype d) {
	Node* newNode = (Node*)malloc(sizeof(Node));
	if (newNode == NULL) {
		printf("内存分配失败!");
		return 0;
	}
	newNode->data = d;
	newNode->next = NULL;
	
	p->tail->next = newNode;
	p->tail = newNode;
	p->size += 1;
	return 1;
}

//出队
int pop(queue* p, etype* res) {
	int sz = size(p);
	if (sz == 0) {
		printf("队列长度为0");
		return 0; 
	}
	
	Node* removedNode = p->head->next;
	if (res != NULL) {
		*res = removedNode->data;
	} 

	p->head->next = removedNode->next;
	if (p->tail == removedNode) {
		p->tail = p->head;
	}
	free(removedNode);
	removedNode = NULL;
	p->size -= 1;
	return 1;	
}

//返回队首
int peek(queue* p, etype* res) {
	int sz = size(p);
	if (sz == 0) {
		printf("队列长度为0");
		return 0; 
	}
	
	
	*res = p->head->next->data;
	
	printf("队头元素为%d\n", *res);
	return 1;	
}
```

## 3.3* 双向队列

# 四、二叉树
## 4.1 定义与基本术语
### 4.1.1 二叉树定义
**二叉树**是一棵**空树**，或者是一棵由**一个根节点和两棵互不相交的，分别称作根的[^1]左子树和右子树组成的非空树**；

### 4.1.2 基本术语
**节点**：包含一个数据元素和左子节点引用和右子节点引用。
**节点的度**：一个节点拥有子树的数目称为节点的度。
**叶子节点**：也称为终端节点，**没有子树**的节点或者**度为零**的节点。
**分支节点**：也称为非终端节点，**度不为零**的节点称为非终端节点。
**节点的深度**：从**根节点**到该节点所经过的边的数量。
**节点的高度**：从距离该节点最远的**叶节点**到该节点所经过的边的数量。

**树的度**：树中所有节点的度的最大值。
**树的高度**：也称为**树的深度**，从根节点到**最远**叶节点所经过的边的数量。
**森林**：由m（m≥0）棵互不相交的树构成一片森林。如果**把一棵非空的树的根节点删除，则该树就变成了一片森林**，森林中的树由原来根节点的各棵子树构成。

> [!NOTE] 歧义
> **结点的层次**从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层。
> ==树的深度或高度 有时为**树中节点的最大层次**，即h≥1。==

### 4.1.3 几种常见的二叉树
**1.完美二叉树**
**完美二叉树（perfect binary tree）** 又称**满二叉树**，所有层的节点都被完全填满。在完美二叉树中，叶节点的度为0，其余所有节点的度都为2；若树的高度为h（h≥0），则节点总数为2^(h+1) - 1，呈现标准的指数级关系。
![[完美二叉树.png]]

**2.完全二叉树**
**完全二叉树（complete binary tree）** 仅允许最底层的节点不完全填满，且最底层的节点必须**从左至右**依次连续填充[^2]。
![[完全二叉树.png]]

**3.完满二叉树**
**完满二叉树（full binary tree）** 除了叶节点之外，其余所有节点都有两个子节点，**即所有节点的度都为0或者2**。

**4.平衡二叉树**
**平衡二叉树（balanced binary tree）** 中任意节点的**左右子树的高度之差**的**绝对值**不超过 1。

**5.二叉搜索树**
**二叉搜索树（Binary Search Tree）** 是一种很常见的二叉树，其**左子树的每个节点**的值都要小于这个节点的值，**右子树的每个节点**的值都要大于这个节点的值。

## 4.2 二叉树的性质
以下节点的深度为该节点的层次，即 h≥1
**性质一：** 二叉树的第k层上至多有**2<sup>k-1</sup>（k≥1）** 个节点。
**性质二：** 深度为 **h(h≥1)** 的二叉树中至多含有**2<sup>h</sup>-1个节点**。
**性质三：** 若在任意一棵二叉树中，有 **n<sub>0</sub>个叶子节点**，有**n<sub>2</sub>个度为2的节点**，则必有**n<sub>0</sub>=n<sub>2</sub>+1**
**性质四：** 具有n个节点的**满二叉树**的深度**h=log 2 (n+1)  (h≥1)**。
**性质五：** 具有n个节点的**完全二叉树**的深度**h =「log<sub>2</sub>n」+ 1  (h≥1)**。
**性质六**：对于非空**完全二叉树**，设其节点数 n ，若 n为奇数，其叶子节点数为 $\frac{n+1}{2}$，若n 为偶数，其叶子节点数为 $\frac{n}{2}$。
**性质七：** 如果对一颗有 n 个节点的**完全二叉树** （其深度 h =「log<sub>2</sub>n」+ 1）的节点按层次编号，则对任意节点 i (1 ≤ i ≤ n)，有：
	①如果 i=1，则节点 i 是二叉树的**根节点**；如果 i>1, 则其**父节点的编号为 i/2**。
	②如果 2i>n，则节点 i **无左子节点，为叶子节点**；否则其**左子节点的编号为 2i**。
	②如果 2i+1>n，则节点 i **无右子节点**；否则其**右子节点的编号为 2i+1**。

## 4.3 二叉树的遍历
从物理结构的角度来看，树是一种基于链表的数据结构，因此其可通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。
### 4.3.1 层序遍历
**层序遍历**（**level-order** traversal）**从顶部到底部**逐层遍历二叉树，并在每一层按照**从左到右**的顺序访问节点。
层序遍历本质上为**广度优先搜索**（breadth-first search, **BFS**），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。
![[二叉树的广度优先遍历.png]]
```c
void levelOrder(TreeNode* root) {
    if (root == NULL) {
        printf("二叉树为空\n");
        return;
    }
    // 创建队列
    queue* q = createQueue();
    if (q == NULL) {
        printf("队列创建失败\n");
        return;
    }
    // 根节点入队
    enqueue(q, root);
    printf("层序遍历结果：");
    // 队列非空时循环
    while (!queueIsEmpty(q)) {
        TreeNode* cur;  // 存储出队的当前节点
        dequeue(q, &cur);  // 出队一个节点
        // 访问当前节点
        printf("%d ", cur->val); //访问节点
        // 左子节点入队（若存在）
        if (cur->left != NULL) {
            enqueue(q, cur->left);
        }
        // 右子节点入队（若存在）
        if (cur->right != NULL) {
            enqueue(q, cur->right);
        }
    }
    printf("\n");
    // 销毁队列
    destroyQueue(q);
}
```

### 4.3.2 递归遍历
递归遍历包括**前序、中序和后序遍历**，其本质上为**深度优先搜索**（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。
![[二叉树的深度优先遍历.png]]
```c
void preOrder(TreeNode* root) {
	if (root == NULL) {
		return;
	}
	printf("%d ", root->val);
	_preOrder(root->left);
	_preOrder(root->right);
}

void inOrder(TreeNode* root) {
	if (root == NULL) {
		return;
	}
	_inOrder(root->left);
	printf("%d ", root->val);
	_inOrder(root->right);
}

void _postOrder(TreeNode* root) {
	if (root == NULL) {
		return;
	}
	_postOrder(root->left);
	_postOrder(root->right);
	printf("%d ", root->val);
}
```

### 4.3.3 二叉树遍历算法的应用
**对于二叉树节点的结构定义**
```c
#include <stdio.h>
#include <stdlib.h>

// 二叉树节点结构定义
typedef struct TreeNode {
    char data;                // 节点存储的数据 (这里用字符)
    struct TreeNode *left;    // 左子节点指针
    struct TreeNode *right;   // 右子节点指针
} TreeNode;
/
```
**1.根据扩展先序遍历序列创建二叉树**
```c
// 全局索引，用于在创建树时追踪扩展先序序列的位置
int g_index = 0;

/**
 * @brief 根据扩展先序遍历序列创建二叉树
 * @param preorder_seq 扩展先序序列字符串 (例如: "ABD##E##CF##G##")
 * @return TreeNode* 返回创建好的二叉树的根节点
 *        A
 *       / \
 *      B   C
 *     / \   \
 *    D   E   F
 *             \
 *              G
 */
TreeNode* createTree(char* preorder_seq) {
    char current_char = preorder_seq[g_index];
    g_index++;

    // 如果当前字符是 '#', 代表空节点
    if (current_char == '#') {
        return NULL;
    }

    // 创建新节点
    TreeNode* new_node = (TreeNode*)malloc(sizeof(TreeNode));
    if (!new_node) {
        printf("内存分配失败!\n");
        exit(1);
    }
    new_node->data = current_char;

    // 递归创建左子树和右子树
    new_node->left = createTree(preorder_seq);
    new_node->right = createTree(preorder_seq);

    return new_node;
}
```

**2.计算二叉树的深度**
```c
/**
 * @brief 计算二叉树的深度
 * @param root 二叉树的根节点
 * @return int 返回树的深度
 */
int treeDepth(TreeNode* root) {
    // 基线条件：空树深度为0
    if (root == NULL) {
        return 0;
    }

    // 递归计算左子树和右子树的深度
    int left_depth = treeDepth(root->left);
    int right_depth = treeDepth(root->right);

    // 树的深度 = max(左子树深度, 右子树深度) + 1
    return (left_depth > right_depth ? left_depth : right_depth) + 1;
}
```

**3.查找两个节点的最近公共祖先**
```c
/**
 * @brief 查找两个节点的最近公共祖先
 * @param root 二叉树的根节点
 * @param p 节点p的值
 * @param q 节点q的值
 * @return TreeNode* 返回LCA节点指针, 如果找不到则返回NULL
 */
TreeNode* findLCA(TreeNode* root, char p, char q) {
    // 基线条件：如果树为空，或者当前节点就是p或q，则返回当前节点
    if (root == NULL || root->data == p || root->data == q) {
        return root;
    }

    // 在左子树和右子树中递归查找
    TreeNode* left_lca = findLCA(root->left, p, q);
    TreeNode* right_lca = findLCA(root->right, p, q);

    // 如果左右子树查找结果都不为空，说明p和q分别在root的两侧，root就是LCA
    if (left_lca != NULL && right_lca != NULL) {
        return root;
    }

    // 否则，LCA在非空的那一侧子树中
    // (如果都为空，则返回NULL，也符合这个逻辑)
    return (left_lca != NULL) ? left_lca : right_lca;
}

```

### 4.3.4 基于遍历序列构造二叉树
任意一种 **“非中序遍历序列”（前序 / 后序 / 层序）与中序遍历序列**组合，或带空节点标记的任意 “非中序遍历序列”可以确定唯一的二叉树。
	==用**非中序找根节点**，用**中序分左右子树**，递归拆解。==
## 4.4* 二叉搜索树
==对于**二叉搜索树 的根节点**，**左子树的每个节点**的值都要小于这个节点的值，**右子树的每个节点**的值都要大于这个节点的值，也被称为二叉顺序树。==同时任意节点的**左、右子树也是二叉搜索树**。
![[二叉搜索树的中序遍历.png]]
由于中序遍历遵循**左->根->右**的遍历顺序，这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，因此可知：**二叉搜索树的中序遍历序列是升序/的**。

> [!NOTE] 二叉搜索树的常见应用
> - 用作系统中的多级索引，实现高效的查找、插入、删除操作。
> - 作为某些搜索算法的底层数据结构。
> - 用于存储数据流，以保持其有序状态。

## 4.5* 平衡二叉树

## 4.6 哈夫曼树
给定**n个权值**，构造一颗有**n个叶子节点**的二叉树，**若该树的带权路径长度（WPL）达到最小**，称这样的二叉树为**最优二叉树**，或称为**哈夫曼树（Huffman Tree）**。其中，==带权路径长度为**树中所有叶子节点的带权路径长度之和**，**叶子节点的带权路径长度**为节点到根节点之间的路径长度与该节点上权的乘积。==


> [!NOTE] 哈夫曼树的特点
> - 哈夫曼树中**权越大**的叶子**离根越近**．
> - 具有相同带权结点的哈夫曼树**不唯一**．
> - 哈夫曼树中**只有度为0或２的结点**，没有度为１的结点.
> - 包含n个叶子结点的哈夫曼树中共有2n-1个结点

### 4.6.1 哈夫曼树的构造
**1.构造算法**
（１）根据n个给定的权值构成n棵二叉树的森林，森林中每一棵树只有一个带权的根结点.（**构造森林全是根**）
（２）在森林中，选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和.（**选用两小造新树**）
（３）在森林中删除这两棵树，同时将新得到的二叉树加入到森林中.（**删除两小添新根**）
（４）重复（２）和（３），直到森林中只有一棵树为止，这棵树即为哈夫曼树．（**重复２，３剩单根**）

**2.代码实现**
```java
@Test
public void createHuffmanTreeTest() {
    int[] arr = {13, 7, 8, 3, 29, 6, 1};
    Node huffmanTree = createHuffmanTree(arr);
}

private Node createHuffmanTree(int[] arr) {
  	// 1.将每个元素转成 Node 对象，并装入 arrayList 中
    List<Node> nodes = new ArrayList<>();
    for (int i : arr) {
        nodes.add(new Node(i));
    }

    while (nodes.size() > 1) {
        // 2. 从小到大排序
        Collections.sort(nodes);

        // 3. 取出两个较小的树
        Node left = nodes.get(0);
        Node right = nodes.get(1);
        // 4. 构成成新的二叉树
        Node parent = new Node(left.value + right.value);
        parent.left = left;
        parent.right = right;
        // 5. 从 list 中删除已经处理过的二叉树
        nodes.remove(left);
        nodes.remove(right);
        // 6. 将新的二叉树添加到 list 中，为下一轮构建做准备
        nodes.add(parent);
    }

    // 返回赫夫曼树的 root 节点
    // 因为前面从小到大排序的，最后一个就是最大节点
    return nodes.get(0);
}

/**
 * 哈夫曼树节点定义
 */
class Node implements Comparable<Node> {
    int value; // 权
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return value + "";
    }

    /**
     * 定义排序规则，从小到大排序
     */
    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

### 4.6.2 哈夫曼编码
**1.哈夫曼编码的定义**
==哈夫曼编码是一种经典的**压缩编码**算法，核心逻辑是按字符**出现概率**分配**不等长编码**。它通过让高频字符对应短码、低频字符对应长码，实现**平均码长最短**的优化目标==，同时满足 “**最优前缀码**” 约束 —— 任一字符的编码都不会成为其他字符编码的前缀，确保解码**无歧义**。

**2.构造方法**
①统计字符集中每个字符在电文中出现的平均概率（**概率越大，码长越短**）。
②利用哈夫曼树的特点：权越大的叶子离根越近。将每个字符的**概率值作为权值**，构造哈夫曼树。
③在哈夫曼树的每个分支上标上0或１：**结点的左分支标0，右分支标１**。把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码．

## 4.7* 线索二叉树
==在二叉链表存储的基础上，将节点中**闲置的空指针**按**某种遍历顺序**指向节点的**前驱节点**或**后继节点**，从而避免遍历过程中频繁递归或栈 / 队列辅助，提高遍历效率。==
# 五、图
## 5.1 图的定义与基本术语
**图(Graph)** 由**顶点 (vertex)的有穷非空集合**和**顶点之间边 (edge)的集合**组成，即 **G=(V, E)**，其中**G表示个图，V是图G中顶点的集合，E是图G中边的集合。**

**1.边**
根据边是否具有方向，可分为**无向图**和**有向图**。
	对于**有向图(directed graph)**，**边是顶点的有序对**，记为<v, w>[^3]，其中 v, w∈G。有向图的边都是有方向的，称之为**有向边**，也可称为**弧**。v可称为弧尾或初始点，w可称为弧头或终端点。
	对于**无向图(undirected graph)**，**边是顶点的无序对**，记为(v, w)[^4]，其中 v, w∈G。有向图的边都是无方向的，称之为**无向边**，(v, w) 和 (w, v) 表示的是同一条边。

根据边是否具有权重，可分为**加权图**和**无权图**。

**2.度**
在无向图中，**度 (degree)** 就是每个节点相连的边的条数。
在有向图中，由于边有方向，所以有向图中每个节点的度被细分为**入度 (indegree)** 和 **出度（outdegree）。**

**3.边与节点**
我们一般讨论的图结构都是**简单图（Simple Graph）**，即没有**自环边（Self loop）** 和**多重边（Multiple edges）** 的图。
![[自环边和多重边.png]]
如果几乎每两个节点之间都有一条边，即 E 接近 V<sup>2</sup>，我们说这幅图是 **稠密图（Dense Graph）**；如果只有很少的边，即 E 远小于 V<sup>2</sup>，我们说这幅图是 **稀疏图（Sparse Graph）**。[^5]

**4.连通性**
对于**无向图**
	对于**连通图**，任意两个节点之间都存在一条路径。
	对于**非连通图**，从任意节点出发，至少有一个节点无法到达。
	**连通分量**：对于非连通的无向图，其中的多个连通子图被称为连通分量，一个图可以有多个连通分量。
对于**有向图**
	如果有向图中任意两个节点之间都存在一条有向路径，我们称之为**强连通图**。即**从任意节点出发都能到达其他所有节点**。
	如果将有向图中的所有**有向边都变成无向边**后，该图变成连通的，那么原来的有向图就是**弱连通图** 。[^6]
	**强连通分量**：有向图中的若干个最大的强连通子图称为强连通分量。
	**弱连通分量**：将有向图的所有有向边变为无向边后，形成的**连通分量**称为原有向图的弱连通分量。
**对于无向连通图和有向强连通图，其对应的连通分量数量都为 1**

## 5.2 图结构的代码实现
### 5.2.1 邻接矩阵
设图的顶点数量为 n，**邻接矩阵**使用一个 **n×n** 大小的矩阵来表示图，**每一行或列代表一个顶点，矩阵元素代表边**，用 0 或 1 表示两个顶点之间是否存在边。邻接矩阵具有以下特性。
	在简单图中，没有自环边，邻接矩阵**主对角线元素没有意义**。
	对于**无向图**，两个方向的边等价，此时邻接矩阵关于主对角线**对称**。
	在有权图终，邻接矩阵的元素为对应边的**权重**。

如果**图的边数接近顶点数的平方** （稠密图） ，或者**频繁地检查任意两点间是否有边**，用邻接矩阵。
无论边数如何改变，邻接矩阵的所占的空间都不变。
**1.java 实现**
```java
// java实现
public class AdjacencyMatrix {
    private int numVertices;
    private int[][] adjMatrix;
    private boolean isDirected;
    private int defaultWeight; // 实例级别的默认权值

    /**
     * 全局默认权值常量。
     * 在“成本/距离”模型中，通常为1。
     * 在“收益/利润”模型中，可以改为 Integer.MIN_VALUE。
     */
    private static final int GLOBAL_DEFAULT_WEIGHT = 1;

    /**
     * 主构造函数：允许用户自定义默认权值。
     * @param numVertices 顶点数量
     * @param isDirected 是否为有向图
     * @param defaultWeight 该图实例的默认边权值
     */
    public AdjacencyMatrix(int numVertices, boolean isDirected, int defaultWeight) {
        this.numVertices = numVertices;
        this.isDirected = isDirected;
        this.defaultWeight = defaultWeight;
        this.adjMatrix = new int[numVertices][numVertices];
    }

     // 便捷构造函数：使用全局默认权值。
    public AdjacencyMatrix(int numVertices, boolean isDirected) {
        this(numVertices, isDirected, GLOBAL_DEFAULT_WEIGHT);
    }

     // 添加一条具有指定权值的边。
    public void addEdge(int v1, int v2, int weight) {
        if (v1 < 0 || v1 >= numVertices || v2 < 0 || v2 >= numVertices) {
            System.out.println("顶点索引超出范围");
            return;
        }
        adjMatrix[v1][v2] = weight;
        if (!isDirected) {
            adjMatrix[v2][v1] = weight;
        }
    }

     // 添加一条使用图实例默认权值的边。
    public void addEdge(int v1, int v2) {
        addEdge(v1, v2, this.defaultWeight);
    }
}
```
**2.c 语言实现**
```c
// c语言实现
#include <stdio.h>
#include <stdlib.h>

// 邻接矩阵结构体
typedef struct {
    int numVertices;   // 顶点数量
    int** adjMatrix;   // 二维数组存储邻接矩阵
    int isDirected;    // 0表示无向图，1表示有向图
} Graph;

// 初始化图
Graph* initGraph(int numVertices, int isDirected) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVertices = numVertices;
    graph->isDirected = isDirected;
    
    // 分配二维数组内存
    graph->adjMatrix = (int**)malloc(numVertices * sizeof(int*));
    for (int i = 0; i < numVertices; i++) {
        graph->adjMatrix[i] = (int*)calloc(numVertices, sizeof(int)); // 初始化为0
    }
    return graph;
}

// 释放内存
void freeGraph(Graph* graph) {
    for (int i = 0; i < graph->numVertices; i++) {
        free(graph->adjMatrix[i]);
    }
    free(graph->adjMatrix);
    free(graph);
}

// 添加边，支持权值
void addEdge(Graph* graph, int v1, int v2, int weight) {
    // 检查顶点合法性
    if (v1 < 0 || v1 >= graph->numVertices || v2 < 0 || v2 >= graph->numVertices) {
        printf("顶点索引超出范围！\n");
        return;
    }
    graph->adjMatrix[v1][v2] = weight;
    // 无向图需对称添加
    if (!graph->isDirected) {
        graph->adjMatrix[v2][v1] = weight;
    }
}
```

### 5.2.2 邻接表
邻接表由**顶点数组**和**邻接链表**，**顶点数组**中每个元素表示**顶点**，在邻接表中被称为**表头节点**，其维护了一个**指针**，指向一个**邻接链表**[^7]，而邻接链表中的每个节点，则被称为**表节点**。
	对于无向图，第 i 个链表将图中与顶点 v<sub>i</sub> 相邻接的所有顶点连接起来，即链表中每一个节点表示了与顶点 v<sub>i</sub> 相关的边。
	对于有向图，第 i 个链表将图中以顶点 v<sub>i</sub> 为尾邻接的的所有顶点连接起来，即链表中每一个节点表示了与顶点 v<sub>i</sub> 为弧尾的边。如果连接以顶点 v<sub>i</sub> 为头的所有顶点，称之为有向图的**逆邻接表**。

如果**图的边数远小于顶点数的平方**（稀疏图），或者你需要**频繁地遍历一个点的所有相邻节点**（如 BFS/DFS），用邻接表。
**1.java 实现**
```java
import java.util.ArrayList;
import java.util.List;

// 邻接表中的边节点（存储邻接顶点索引和权值）
class EdgeNode {
    int adjVertex;  // 邻接顶点的索引
    int weight;     // 边的权值

    public EdgeNode(int adjVertex, int weight) {
        this.adjVertex = adjVertex;
        this.weight = weight;
    }
}

// 邻接表实现的图
public class AdjacencyList {
    private int numVertices;
    private List<List<EdgeNode>> list;
    private boolean isDirected;
    private int defaultWeight; // 实例级别的默认权值

    // 静态常量，作为全局默认权值
    private static final int GLOBAL_DEFAULT_WEIGHT = 1;

    // 主构造函数：允许用户自定义默认权值
    public AdjacencyList(int numVertices, boolean isDirected, int defaultWeight) {
        this.numVertices = numVertices;
        this.isDirected = isDirected;
        this.defaultWeight = defaultWeight;
        list = new ArrayList<>(numVertices);
        for (int i = 0; i < numVertices; i++) {
            list.add(new ArrayList<>());
        }
    }

    // 便捷构造函数：使用全局默认权值
    public AdjacencyList(int numVertices, boolean isDirected) {
        this(numVertices, isDirected, GLOBAL_DEFAULT_WEIGHT);
    }

    // 添加边，支持权值
    public void addEdge(int v1, int v2, int weight) {
        if (v1 < 0 || v1 >= numVertices || v2 < 0 || v2 >= numVertices) {
            System.out.println("顶点索引超出范围");
            return;
        }
        // 向v1的邻接列表添加v2
        list.get(v1).add(new EdgeNode(v2, weight));
        // 无向图需对称添加（v2的邻接列表添加v1）
        if (!isDirected) {
            list.get(v2).add(new EdgeNode(v1, weight));
        }
    }

    // 默认权值为1
    public void addEdge(int v1, int v2) {
        addEdge(v1, v2, 1);
    }
```
**2.c 语言实现**
```c
#include <stdio.h>
#include <stdlib.h>

// 边节点结构体（存储邻接顶点索引和权值，以及下一个边节点指针）
typedef struct EdgeNode {
    int adjVertex;          // 邻接顶点的索引
    int weight;             // 边的权值
    struct EdgeNode* next;  // 下一个邻接顶点
} EdgeNode;

// 顶点结构体（存储顶点索引和对应的边链表头指针）
typedef struct VertexNode {
    int vertex;             // 顶点索引（可扩展为顶点数据）
    EdgeNode* firstEdge;    // 边链表的头指针
} VertexNode;

// 邻接表结构体
typedef struct {
    VertexNode* vertices;   // 顶点数组
    int numVertices;        // 顶点数量
    int isDirected;         // 0：无向图，1：有向图
} Graph;

// 初始化图
Graph* initGraph(int numVertices, int isDirected) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVertices = numVertices;
    graph->isDirected = isDirected;
    // 分配顶点数组内存并初始化
    graph->vertices = (VertexNode*)malloc(numVertices * sizeof(VertexNode));
    for (int i = 0; i < numVertices; i++) {
        graph->vertices[i].vertex = i;          // 顶点索引为i
        graph->vertices[i].firstEdge = NULL;    // 初始无邻接顶点
    }
    return graph;
}

// 创建新的边节点
EdgeNode* createEdgeNode(int adjVertex, int weight) {
    EdgeNode* node = (EdgeNode*)malloc(sizeof(EdgeNode));
    node->adjVertex = adjVertex;
    node->weight = weight;
    node->next = NULL;
    return node;
}

// 添加边，支持权值
void addEdge(Graph* graph, int v1, int v2, int weight) {
    if (v1 < 0 || v1 >= graph->numVertices || v2 < 0 || v2 >= graph->numVertices) {
        printf("顶点索引超出范围！\n");
        return;
    }
    // 向v1的边链表头部插入v2
    EdgeNode* newNode = createEdgeNode(v2, weight);
    newNode->next = graph->vertices[v1].firstEdge;
    graph->vertices[v1].firstEdge = newNode;

    // 无向图需对称添加（v2的边链表插入v1）
    if (!graph->isDirected) {
        EdgeNode* newNode2 = createEdgeNode(v1, weight);
        newNode2->next = graph->vertices[v2].firstEdge;
        graph->vertices[v2].firstEdge = newNode2;
    }
}

// 释放图的内存
void freeGraph(Graph* graph) {
    for (int i = 0; i < graph->numVertices; i++) {
        EdgeNode* cur = graph->vertices[i].firstEdge;
        while (cur != NULL) {
            EdgeNode* temp = cur;
            cur = cur->next;
            free(temp); // 释放边节点
        }
    }
    free(graph->vertices); // 释放顶点数组
    free(graph);           // 释放图结构体
}
```

## 5.3 图的遍历
[图的遍历 - Hello 算法](https://www.hello-algo.com/chapter_graph/graph_traversal/)
### 5.3.1 广度优先遍历
**广度优先遍历**是一种**由近及远**的遍历方式，从某个节点出发，始终**优先访问距离最近**的顶点，并一层层**向外扩张**。其**借助一个哈希集合[^8] `visited` 来判断一个顶点是否已经被访问过**。==类似于二叉树的层序遍历，运用到队列==
```java
/* 广度优先遍历 */
// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
void graphBFS(GraphAdjList graph, Vertex startVet) {
    // 集合，用于记录已被访问过的顶点
    Set<Vertex> visited = new HashSet<>();
    visited.add(startVet);
    // 队列，用于记录待访问的顶点，实现 BFS
    Queue<Vertex> que = new LinkedList<>();
    que.offer(startVet);
    
    // 以顶点 vet 为起点，循环直至访问完所有顶点
    while (!que.isEmpty()) {
        Vertex vet = que.poll(); // 队首顶点出队
        System.out.print(vet + "->"); // 访问顶点
        // 遍历该顶点的所有邻接顶点
        for (Vertex adjVet : graph.adjList.get(vet)) {
            if (visited.contains(adjVet))
                continue;        // 跳过已被访问的顶点
            que.offer(adjVet);   // 只入队未访问的顶点
            visited.add(adjVet); // 标记该顶点已被访问
        }
    }
    System.out.println("遍历结束");
}
```

**广度优先搜索的应用**
```java
//洛谷-P1162填涂颜色

import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList;

public class Main{
    static int n;
    static int[][] arr;
    static int[] xm = {0, 0, -1, 1};
    static int[] ym = {-1, 1, 0, 0};
    static Queue<int[]> queue = new LinkedList<>();
    
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        arr = new int[n + 2][n + 2];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                arr[i][j] = scan.nextInt();
            }
        }

        bfs();

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (arr[i][j] == -1) {
                    System.out.print("0 ");
                } else if (arr[i][j] == 1) {
                    System.out.print("1 ");
                } else {
                    System.out.print("2 ");
                }
            }
            System.out.println();
        }
        
    }
    
    public static void bfs() {
        int[] begin = {0, 0};
        arr[0][0] = -1;
        queue.offer(begin);

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0];
            int y = current[1];

            for (int i = 0; i < 4; i++) {
                int xi = x + xm[i];
                int yi = y + ym[i];

                if (xi >= 0 && xi <= n + 1 && yi >= 0 && yi<= n + 1 && arr[xi][yi] == 0) {
                    int[] temp = {xi, yi};
                    queue.offer(temp);
                    arr[xi][yi] = -1;
                    
                }
            }
        }
    }
}
```

### 5.3.2 深度优先遍历
**深度优先遍历**是一种**优先走到底、无路可走再回头**的遍历方式。**与广度优先遍历类似**，在深度优先遍历中，我们也需要借助一个哈希集合 **`visited`** 来记录已被访问的顶点，**以避免重复访问顶点**。==类似于二叉树的先序遍历，运用到递归/栈结构==
```java
/* 深度优先遍历辅助函数 */
void dfs(GraphAdjList graph, Set<Vertex> visited, Vertex vet) {
    System.out.print(vet + "->"); // 访问顶点
    visited.add(vet); // 标记该顶点已被访问
    // 遍历该顶点的所有邻接顶点
    for (Vertex adjVet : graph.adjList.get(vet)) {
        if (visited.contains(adjVet))
            continue; // 跳过已被访问的顶点
        // 递归访问邻接顶点
        dfs(graph, visited, res, adjVet);
    }
}

/* 深度优先遍历 */
// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
void graphDFS(GraphAdjList graph, Vertex startVet) {
    // 哈希集合，用于记录已被访问过的顶点
    Set<Vertex> visited = new HashSet<>();
    dfs(graph, visited, startVet);
    System.out.println("遍历结束");
}
```

上述代码**存在局限性**，它只能访问与起始点相连的连通分量（**连通图**）。要解决这个问题，我们需要在主遍历逻辑外包裹一层循环。这个循环会检查图中的每一个顶点，**如果发现某个顶点还未被访问过，就立刻从它开始执行一次新的遍历，直到图中所有顶点都被访问为止**。

**深度优先搜索的应用**
```java
//洛谷-P1162填涂颜色

import java.util.Scanner;

public class Main{
    static int n;
    static int[][] arr;
    
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        arr = new int[n + 2][n + 2];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                arr[i][j] = scan.nextInt();
            }
        }

        dfs(0, 0);

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (arr[i][j] == -1) {
                    System.out.print("0 ");
                } else if (arr[i][j] == 1) {
                    System.out.print("1 ");
                } else {
                    System.out.print("2 ");
                }
            }
            System.out.println();
        }
        
    }
    
    public static void dfs(int x, int y) {
        if (x < 0 || y < 0 || x >= n+ 2 || y >= n+ 2 || arr[x][y] != 0) {
            return;
        }
        arr[x][y] = -1;

        dfs(x + 1, y);
        dfs(x - 1, y);
        dfs(x, y + 1);
        dfs(x, y - 1);
    }
}
```
## 5.4 最短路径算法
### 5.4.1 Dijkstra 算法
**Dijkstra算法**是一种用于在**加权图**中，查找从**单一源点**到所有其他顶点的**最短路径**的经典算法。它由荷兰计算机科学家艾兹赫尔·迪杰斯特拉在1956年提出。它只能正确处理**所有边的权重（或“成本”）** 均为**非负值**的图。[最短路径-Dijkstra(迪杰斯特拉)算法](https://www.bilibili.com/video/BV1uT4y1p7Jy)

> [!NOTE] 算法步骤
> 1.初始化 $dist$ 数组，$dist[i]$ 表示从起点到顶点 $i$ 的最短路径长度。
> 2.从起点开始，每次选择当前未访问的顶点中距离起点最近的顶点，更新其邻接顶点的最短路径长度。
> 3. 直到所有顶点都访问过。
> 4.若$dist$数组中有顶点的值为 $\infty$,则该顶点不可达。

**1.基于邻接矩阵实现的图**
```java
import java.util.Arrays;
import java.util.Scanner;

/**
 * Dijkstra算法的清晰实现
 * 该实现使用邻接矩阵来表示图，并通过迭代的方式逐步确定从起点到所有其他节点的最短路径。
 */
public class ShortestPathFinder {

    // 使用正无穷大表示两个节点之间不直接相连
    private static final double INFINITY = Double.POSITIVE_INFINITY;

    /**
     * 计算从指定起点到图中所有其他节点的最短路径。
     *
     * @param graph     图的邻接矩阵。graph[i][j] 表示节点 i 到节点 j 的直接距离。
     * @param startNode 起始节点的索引（从0开始）。
     * @return 一个一维数组，存储了从起点到每个节点的最短距离。
     */
    public static double[] findShortestPaths(double[][] graph, int startNode) {
        int totalNodes = graph.length;

        // 记录每个节点是否已被确定为最短路径
        // true 表示已确定，false 表示待确定
        boolean[] isFinalized = new boolean[totalNodes];

        // 存储从起点到每个节点的当前最短距离估计值
        double[] distances = new double[totalNodes];
        // 初始时，所有距离都设为无穷大
        Arrays.fill(distances, INFINITY);

        // 起点到自身的距离为0
        distances[startNode] = 0;

        // 循环 totalNodes 次，每次确定一个节点的最短路径
        for (int i = 0; i < totalNodes; i++) {

            // --- 步骤 1: 从当前未确定的节点中，找到距离起点最近的节点 ---
            int closestNode = -1;
            double minDistance = INFINITY;

            for (int nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {
                // 如果节点未被确定，且其距离小于当前记录的最小距离
                if (!isFinalized[nodeIndex] && distances[nodeIndex] < minDistance) {
                    minDistance = distances[nodeIndex];
                    closestNode = nodeIndex;
                }
            }

            // 如果找不到可达的未确定节点（所有剩余节点都是INFINITY），则提前结束
            if (closestNode == -1) {
                break;
            }

            // --- 步骤 2: 将找到的最近节点标记为“已确定” ---
            isFinalized[closestNode] = true;

            // --- 步骤 3: 以新确定的节点为中心，更新其所有邻居的距离估计值 ---
            // 这一步被称为“松弛操作”
            for (int neighborIndex = 0; neighborIndex < totalNodes; neighborIndex++) {
                // 计算经过 closestNode 到达 neighborIndex 的新路径长度
                double pathThroughClosestNode = distances[closestNode] + graph[closestNode][neighborIndex];

                // 如果新路径比当前记录的路径更短，则更新距离
                // 注意：只有当 graph[closestNode][neighborIndex] 不是 INFINITY 时，新路径才有效
                if (!isFinalized[neighborIndex] && graph[closestNode][neighborIndex] != INFINITY
                        && pathThroughClosestNode < distances[neighborIndex]) {
                    distances[neighborIndex] = pathThroughClosestNode;
                }
            }
        }

        return distances;
    }

	/*
    public static void main(String[] args) {
        // 定义图的邻接矩阵
        double[][] graphMatrix = {};

        //定义初始节点
        int startNodeIndex = scanner.nextInt();

        // 调用Dijkstra算法计算最短路径
        double[] shortestDistances = findShortestPaths(graphMatrix, startNodeIndex);
    }
    */
}
```
**2*.基于邻接表实现的图**
### 5.4.2 Floyd 算法
**Floyd 算法**是一种经典的**动态规划**算法，用于在**加权有向图**中寻找**所有顶点对之间的最短路径**，其核心思想是**动态规划中的“状态转移”**。**它能处理负权边但不能处理负权环。**[最短路径-Floyd(弗洛伊德)算法](https://www.bilibili.com/video/BV19k4y1Q7Gj)

> [!NOTE] 算法步骤
> 1.初始化 $dist$ 距离矩阵 $dist[i][j]$ 表示从顶点 $i$ 到顶点 $j$ 的最短路径长度。
> 2.引入中间顶点 $k$（遍历所有顶点，作为中转节点），对于每一对顶点 $(i, j)$，更新最短路径。
> 3.遍历完所有中间顶点 $k$ 后，距离矩阵 $dist$ 稳定，此时 $dist[i][j]$ 即为顶点 $i$ 到顶点 $j$ 的最终最短路径长度。
> 4. 若最终 $dist[i][j]$ 仍为 $\infty$，则顶点 $i$ 到顶点 $j$ 不可达。


```java
/**
 * Floyd算法核心实现
 * 用于计算图中所有顶点对之间的最短路径
 */
public class FloydAlgorithm {

    /**
     * 执行Floyd算法
     * @param graph 邻接矩阵表示的图，graph[i][j]表示顶点i到j的边的权重
     * @param dist 最短路径距离数组，dist[i][j]表示顶点i到j的最短距离
     * @param path 路径数组，path[i][j]表示顶点i到j的最短路径上j的前驱顶点
     */
    public static void floyd(int[][] graph, int[][] dist, int[][] path) {
        int n = graph.length; // 图的顶点数量

        // 初始化dist和path数组
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = graph[i][j]; // 初始距离即为边的权重
                path[i][j] = (graph[i][j] != Integer.MAX_VALUE && i != j) ? i : -1; // 初始化前驱顶点
            }
        }

        // 核心算法：尝试以每个顶点为中间点，更新最短路径
        for (int k = 0; k < n; k++) { // 中间顶点k
            for (int i = 0; i < n; i++) { // 起始顶点i
                for (int j = 0; j < n; j++) { // 终点顶点j
                    // 如果i到k和k到j的路径都存在，且比当前i到j的路径更短
                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE 
                        && dist[i][k] + dist[k][j] < dist[i][j]) {
                        // 更新最短距离
                        dist[i][j] = dist[i][k] + dist[k][j];
                        // 更新路径：j的前驱设为k的前驱
                        path[i][j] = path[k][j];
                    }
                }
            }
        }
    }
}
```
## 5.5 最小生成树算法
[最小生成树-Prim(普里姆)算法和Kruskal(克鲁斯卡尔)算法](https://www.bilibili.com/video/BV1wG411z79G)
### 5.5.1 前置知识
#### 5.5.1.1 最小生成树的定义
设**带权连通无向图** $G=(V,E,w)$,其中 $w:E\to R$ 为边的权重函数。若 $T=(V,E_{min},w)$ 满足以下三个条件，则称 $T$ 为 $G$ 的最小生成树：
	1. **连通性**：$T$ 是连通图，即 $T$ 中任意两个顶点之间都存在路径。
	2. **无环性**：$T$ 是无环图，不存在任何回路。
	3. **最小权重性**：$T$ 的总权重是所有满足前两个条件的子图中最小的，即 $w(T)=\sum_{e\in E_{min}}w(e)=\min\left\{\sum_{e\in E^{\prime}}w(e)\mid E^{\prime}\subseteq E,\left(V,E^{\prime}\right)\text{连通且无环}\right\}$

最小生成树是无向连通图的**极小连通子图**，恰好有 n-1 条边连接 n 个顶点，即去除任意一条边都可以使连通图变成非连通图。
#### 5.5.1.2* Union-Find 并查集
```c
#include <stdio.h>
#include <stdlib.h>

// --- 数据结构定义 ---

/**
 * @brief 并查集的节点结构体
 * @var parent 父节点的索引。根节点的 parent 是它自己。
 * @var rank 秩（或高度）。用于按秩合并优化，近似表示树的高度。
 */
typedef struct {
    int parent;
    int rank;
} Subset;

// --- 核心函数实现 ---

/**
 * @brief 创建并初始化一个并查集
 * @param n 集合中元素的总数
 * @param subsets 指向并查集数组的指针（需要在外部分配内存）
 * @note 初始化时，每个元素都是独立的集合，其父节点指向自身，秩为0。
 */
void makeSet(int n, Subset subsets[]) {
    for (int i = 0; i < n; i++) {
        subsets[i].parent = i;
        subsets[i].rank = 0;
    }
}

/**
 * @brief 查找操作：查找元素 i 所在集合的根节点
 * @param subsets 并查集数组
 * @param i 要查找的元素索引
 * @return 根节点的索引
 * @note 实现了路径压缩优化，使查找后的树更扁平，从而加速后续查找。
 */
int find(Subset subsets[], int i) {
    // 递归基准：如果 i 的父节点是它自己，那么 i 就是根节点
    if (subsets[i].parent != i) {
        // 路径压缩：将 i 的父节点直接设置为根节点
        // 这行代码会递归地找到根节点，并将路径上所有节点都指向根
        subsets[i].parent = find(subsets, subsets[i].parent);
    }
    return subsets[i].parent;
}

/**
 * @brief 合并操作：合并两个元素所在的集合
 * @param subsets 并查集数组
 * @param x 元素1的索引
 * @param y 元素2的索引
 * @note 实现了按秩合并优化，总是将秩较小的树合并到秩较大的树下。
 */
void unionSet(Subset subsets[], int x, int y) {
    // 1. 找到 x 和 y 所在集合的根节点
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    // 2. 如果根节点相同，说明它们已在同一个集合中，无需操作
    if (xroot == yroot) {
        return;
    }

    // 3. 按秩合并
    // 将秩较小的树挂到秩较大的树下
    if (subsets[xroot].rank < subsets[yroot].rank) {
        subsets[xroot].parent = yroot;
    } else if (subsets[xroot].rank > subsets[yroot].rank) {
        subsets[yroot].parent = xroot;
    } else {
        // 如果两棵树的秩相同，则任选一个作为新的根
        // 并将新根的秩加1
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}
```
#### 5.5.1.3* 最小堆结构
```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> 

// --- 数据结构定义 ---

/**
 * @brief 最小堆的节点结构体
 * @var v 元素的标识符（例如，图中的顶点索引）
 * @var key 元素的优先级（或权重），key值越小，优先级越高
 */
typedef struct MinHeapNode {
    int v;
    int key;
} MinHeapNode;

/**
 * @brief 最小堆结构体
 * @var size 当前堆中元素的数量
 * @var capacity 堆的总容量
 * @var pos 位置映射数组。pos[v] 存储着元素 v 在堆数组 array 中的索引。
 *           这是实现 decreaseKey 操作的关键，可以将时间复杂度从 O(N) 降至 O(logN)。
 * @var array 指向堆节点指针数组的指针，用于存储堆中的所有节点
 */
typedef struct MinHeap {
    int size;
    int capacity;
    int *pos;             // 位置数组
    struct MinHeapNode **array;
} MinHeap;


// --- 核心函数实现 ---

/**
 * @brief 创建一个新的堆节点
 * @param v 元素标识符
 * @param key 优先级键值
 * @return 指向新创建节点的指针
 */
MinHeapNode* newMinHeapNode(int v, int key) {
    MinHeapNode* node = (MinHeapNode*)malloc(sizeof(MinHeapNode));
    node->v = v;
    node->key = key;
    return node;
}

/**
 * @brief 创建一个最小堆
 * @param capacity 堆的容量
 * @return 指向新创建的最小堆的指针
 */
MinHeap* createMinHeap(int capacity) {
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));
    heap->pos = (int *)malloc(capacity * sizeof(int));
    heap->size = 0;
    heap->capacity = capacity;
    heap->array = (MinHeapNode**)malloc(capacity * sizeof(MinHeapNode*));
    return heap;
}

/**
 * @brief 交换两个堆节点指针（内部辅助函数）
 * @param a 指向第一个节点指针的指针
 * @param b 指向第二个节点指针的指针
 */
void swapMinHeapNode(MinHeapNode** a, MinHeapNode** b) {
    MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

/**
 * @brief 最小堆的向下调整（堆化）操作
 * @param heap 最小堆指针
 * @param idx 需要调整的节点索引
 * @note 这是堆排序和插入操作的核心，用于维护堆的性质
 */
void minHeapify(MinHeap* heap, int idx) {
    int smallest, left, right;
    smallest = idx;
    left = 2 * idx + 1;
    right = 2 * idx + 2;

    // 比较当前节点与其左子节点
    if (left < heap->size &&
        heap->array[left]->key < heap->array[smallest]->key)
      smallest = left;

    // 比较当前最小节点与其右子节点
    if (right < heap->size &&
        heap->array[right]->key < heap->array[smallest]->key)
      smallest = right;

    // 如果当前节点不是最小的，则与最小的子节点交换，并继续向下调整
    if (smallest != idx) {
        // 交换节点
        MinHeapNode* smallestNode = heap->array[smallest];
        MinHeapNode* idxNode = heap->array[idx];

        // 关键：交换后必须更新 pos 数组
        heap->pos[smallestNode->v] = idx;
        heap->pos[idxNode->v] = smallest;

        swapMinHeapNode(&heap->array[smallest], &heap->array[idx]);

        // 递归地对受影响的子树进行堆化
        minHeapify(heap, smallest);
    }
}

/**
 * @brief 检查堆是否为空
 * @param heap 最小堆指针
 * @return 1 表示为空，0 表示非空
 */
int isHeapEmpty(MinHeap* heap) {
    return heap->size == 0;
}

/**
 * @brief 从堆中提取键值最小的节点
 * @param heap 最小堆指针
 * @return 指向被提取的节点的指针（调用者负责释放内存）
 */
MinHeapNode* extractMin(MinHeap* heap) {
    if (isHeapEmpty(heap))
        return NULL;

    // 根节点就是最小节点
    MinHeapNode* root = heap->array[0];

    // 将最后一个节点放到根的位置
    MinHeapNode* lastNode = heap->array[heap->size - 1];
    heap->array[0] = lastNode;

    // 更新位置映射
    heap->pos[root->v] = heap->size - 1;
    heap->pos[lastNode->v] = 0;

    // 堆大小减1
    --heap->size;

    // 对新的根节点进行堆化，以维护堆性质
    minHeapify(heap, 0);

    return root;
}

/**
 * @brief 减小堆中某个元素的键值
 * @param heap 最小堆指针
 * @param v 要减小键值的元素标识符
 * @param new_key 新的键值
 * @note 这是 Prim 算法等应用中的关键操作
 */
void decreaseKey(MinHeap* heap, int v, int new_key) {
    // 1. 通过 pos 数组找到元素 v 在堆数组中的索引
    int i = heap->pos[v];

    // 2. 更新其键值
    heap->array[i]->key = new_key;

    // 3. 向上调整，直到堆性质恢复
    //    只要当前节点的键值小于其父节点，就交换它们
    while (i && heap->array[i]->key < heap->array[(i - 1) / 2]->key) {
        // 交换节点
        heap->pos[heap->array[i]->v] = (i - 1) / 2;
        heap->pos[heap->array[(i - 1) / 2]->v] = i;
        swapMinHeapNode(&heap->array[i], &heap->array[(i - 1) / 2]);

        // 移动到父节点的位置
        i = (i - 1) / 2;
    }
}

/**
 * @brief 检查一个元素是否在堆中
 * @param heap 最小堆指针
 * @param v 要检查的元素标识符
 * @return 1 表示在堆中，0 表示不在
 */
int isInMinHeap(MinHeap* heap, int v) {
   if (heap->pos[v] < heap->size)
     return 1;
   return 0;
}

// --- 内存释放 ---

/**
 * @brief 销毁最小堆，释放其占用的所有内存
 * @param heap 最小堆指针
 */
void destroyMinHeap(MinHeap* heap) {
    if (!heap) return;

    // 释放所有堆节点
    for (int i = 0; i < heap->capacity; ++i) {
        free(heap->array[i]);
    }
    
    // 释放节点指针数组
    free(heap->array);
    // 释放位置映射数组
    free(heap->pos);
    // 释放堆结构体本身
    free(heap);
}
```
### 5.5.2 Kruskal 算法
==**Kruskal 算法**是一种**贪心算法**，它通过**按边的权重从小到大**的顺序，逐步选择不会形成环的边来构建最小生成树。==
从**边**的视角出发，利用**并查集**高效判断环路，通过全局排序选择最小边来构建生成树，尤其适合==稀疏图==。

```c
#include <stdio.h>
#include <stdlib.h>

// --- 数据结构定义 ---

// 图的边结构体
typedef struct {
    int src, dest;    // 边的两个顶点
    int weight;       // 边的权重
} Edge;

// 图的结构体
typedef struct {
    int V, E;         // V: 顶点数量, E: 边数量
    Edge* edge;       // 边数组的指针
} Graph;


// --- 数据结构定义 ---

/**
 * @brief 比较函数，用于 qsort 对边按权重升序排序
 */
int compareEdges(const void* a, const void* b) {
    Edge* edgeA = (Edge*)a;
    Edge* edgeB = (Edge*)b;
    return edgeA->weight - edgeB->weight;
}

/**
 * @brief Kruskal 算法核心函数
 * @param graph 输入的图
 * @param result 存储结果的边数组 (大小为 V-1)
 * @return 最小生成树的总权重
 */
int Kruskal(Graph graph, Edge result[]) {
    int V = graph.V;
    int E = graph.E;
    // 按权重对所有边进行排序
    qsort(graph.edge, E, sizeof(Edge), compareEdges);

    // 1. 初始化并查集，每个顶点自成一个集合
    Subset* subsets = (Subset*)malloc(V * sizeof(Subset));
    for (int v = 0; v < V; ++v) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    int e = 0;       // result[] 数组的索引
    int total_weight = 0; // 最小生成树的总权重

    // 2. 遍历所有排序后的边
    for (int i = 0; e < V - 1 && i < E; ++i) {
        Edge next_edge = graph.edge[i];

        // 3. 使用并查集检查加入此边是否会形成环路
        int root_src = find(subsets, next_edge.src);
        int root_dest = find(subsets, next_edge.dest);

        // 如果根节点不同，说明这条边是安全的，不会形成环路
        if (root_src != root_dest) {
            // 将此边加入结果集
            result[e++] = next_edge;
            total_weight += next_edge.weight;
            // 合并这两个顶点所在的集合
            Union(subsets, root_src, root_dest);
        }
        // 如果根节点相同，则舍去此边，继续检查下一条
    }

    free(subsets);
    return total_weight;
}
```
### 5.5.3 Prim 算法
==**Prim 算法**也是一种**贪心算法**，它从一个初始顶点出发，通过**每次选择离当前生成树最近的一个顶点**（即权重最小的连接边）来逐步扩大生成树，直到包含所有顶点。==
从**顶点**的视角出发，利用**优先队列（最小堆）** 高效查找最近邻，通过不断将离当前树最近的顶点加入来扩展生成树，尤其适合==稠密图==。

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // 用于 INT_MAX

// --- 数据结构定义 ---

// 邻接表中的节点
typedef struct AdjListNode {
    int dest;           // 邻接顶点的索引
    int weight;         // 边的权重
    struct AdjListNode* next;
} AdjListNode;

// 邻接表
typedef struct AdjList {
    AdjListNode* head;  // 指向邻接表第一个节点的指针
} AdjList;

// 图的结构体（使用邻接表表示）
typedef struct {
    int V;              // 顶点数量
    AdjList* array;     // 邻接表数组
} Graph;

// --- 最小堆 核心实现 ---
// --- Prim 算法核心 ---

/**
 * @brief Prim 算法核心函数
 * @param graph 输入的图
 * @param parent 存储结果的父节点数组 (parent[v] 表示 v 在MST中的父节点)
 * @return 最小生成树的总权重
 */
int Prim(Graph graph, int parent[]) {
    int V = graph.V;
    int total_weight = 0; // 最小生成树的总权重

    // key[] 数组记录所有顶点到当前生成树的最小权重
    int* key = (int*)malloc(V * sizeof(int));
    
    // 创建最小堆，用于高效获取 key 值最小的顶点
    MinHeap* heap = createMinHeap(V);
    
    // 1. 初始化
    for (int v = 1; v < V; ++v) {
        parent[v] = -1;       // 初始时，所有顶点（除根节点）的父节点为-1
        key[v] = INT_MAX;     // 初始时，所有顶点的 key 为无穷大
        heap->array[v] = newMinHeapNode(v, key[v]);
        heap->pos[v] = v;
    }

    // 从顶点 0 开始
    key[0] = 0;
    heap->array[0] = newMinHeapNode(0, key[0]);
    heap->pos[0] = 0;
    parent[0] = -1; // 根节点的父节点为-1

    heap->size = V; // 初始时，所有顶点都在堆中

    // 2. 当堆中还有顶点时，循环
    while (!isHeapEmpty(heap)) {
        // 3. 提取 key 值最小的顶点 u
        MinHeapNode* heapNode = extractMin(heap);
        int u = heapNode->v;
        free(heapNode);

        // 4. 遍历 u 的所有邻接顶点 v
        AdjListNode* pCrawl = graph.array[u].head;
        while (pCrawl != NULL) {
            int v = pCrawl->dest;

            // 如果 v 仍在堆中，且 u-v 的权重小于 v 当前的 key 值
            if (isInMinHeap(heap, v) && pCrawl->weight < key[v]) {
                parent[v] = u;          // 更新 v 的父节点为 u
                key[v] = pCrawl->weight; // 更新 v 的 key 值
                decreaseKey(heap, v, key[v]); // 调整 v 在堆中的位置
            }
            pCrawl = pCrawl->next;
        }
    }

    // 计算总权重
    for (int i = 1; i < V; ++i) {
        total_weight += key[i];
    }

    free(key);
    free(heap->array);
    free(heap->pos);
    free(heap);
    
    return total_weight;
}
```

## 5.6 关于图的其它知识
### 5.6.1 拓扑排序
**拓扑排序**是针对 **有向无环图** 的一种排序算法，其核心是将图中所有顶点排成一个线性序列。对于图中任意一条**有向边** $(u,v)$，顶点 u 在序列中一定位于顶点 v 的前面。
![[拓扑排序示例.png]]
==**每次选择入度为 0 的点，然后删除这个点和它的出边**==。一个有向无环图可以有**一个或多个**拓扑排序序列。
### 5.6.2 关键路径
**1.AOV网**
在有向图中，用**顶点表示活动**，用**有向边表示活动的优先关系**，则称这种有向图为 **AOV网**；AOV 网络可以通过拓扑排序反映任务完成的先后顺序。

**2.AOE网（Activity On Edge 网）**
在带权有向图中若**以顶点表示事件**，**有向边表示活动**，边上的**权值表示该活动持续的时间**，这样的图简称为**AOE网**。

**关键活动**是指在**AOE 网**中，**总持续时间等于关键路径长度的活动**，也是决定整个工程最短完成时间的核心活动。**关键路径**是从开始点到完成点的最长路径的长度。
[图-AOE网和关键路径](https://www.bilibili.com/video/BV1dy421a7S1)
# 六、哈希表

# 七、搜索算法
## 7.1 平均查找长度
**平均查找长度（ASL）** 是衡量查找算法效率的核心指标，在查找过程中，**成功查找时平均比较的关键字次数**，或**包含成功 / 失败两种情况的平均比较次数**。
$$\mathrm{ASL}_\text{成功}=\sum_{i=1}^np_i\times c_i$$
若所有元素查找概率相等 $p_i=\frac{1}{n}$，则公式简化为：
$$\mathrm{ASL}_\text{成功}=\frac{1}{n}\sum_{i=1}^nc_i$$
其中 $n$ 为**元素总数**，$p_j$ 为第 $i$ 个元素的**查找概率**, $c_j$ 为第 i 个元素的**比较次数**。若查找失败，则 ASL 定义为：
$$\mathrm{ASL}_\text{失败}=\sum_{j=1}^mq_j\times c_j^{\prime}$$
其中 $m$ 查找失败的**总情况数**，$q_j$ 第 j 种失败情况的**查找概率**，$c_j^{\prime}$ 为第 j 种失败情况的**比较次数**。
## 7.2 静态搜索
### 7.2.1 线性查找
```cpp
for i in range(n):
    if A[i] == key: return i
```
懂的都懂!!
### 7.2.2 二分查找
**二分查找**是用于查找**有序数组**中目标值位置的搜索算法。二分查找比较目标值与数组中间元素的大小，如果两者不相等，则会舍弃不可能包含目标值的那一半区间，然后在剩余区间重复此过程：每次选取新的中间元素并与目标值比较，直至找到目标或区间为空。若区间为空，则说明目标值不存在。
```java
public static int binarySearch(int[] arr, int target) {  
    int left = 0;  
    int right = arr.length - 1;  
  
    while (left <= right) {  
        int mid = left + ((right - left) >> 1);  
  
        if (arr[mid] > target) {  
            right = mid - 1;  
        } else if (arr[mid] < target) {  
            left = mid + 1;  
        } else {  
            return mid;  
        }  
    }  
    return -1;  
}
```
### 7.2.3* 插值查找 / 斐波那契查找

## 7.3 动态查找
### 7.3.1 二叉搜索树查找
[[#4.4* 二叉搜索树]]
### 7.3.2 哈希查找
[[#六、哈希表]]
### 7.3.3* 平衡二叉树查找（AVL / 红黑树）
[[#4.5* 平衡二叉树]]
### 7.3.4* B 树 / B+ 树查找查找
[[#4.5* 平衡二叉树]]
# 八、十大排序算法
## 8.1 冒泡排序
**冒泡排序（Bubble Sort）** 是一种简单的排序算法，它通过重复地遍历待排序的列表，**比较相邻的元素并交换它们的位置**来实现排序。这个过程就像水中的气泡一样，底端的元素会经过交换慢慢“浮”到序列的顶端。
从第一个元素开始，依次比较相邻的两个元素。如果前一个元素大于后一个元素，则交换它们的位置。一轮下来，最大的元素就会被“冒泡”到数列的末尾。重复以上步骤，但每次比较的范围都向前缩小一位。
![[冒泡排序.gif]]
```java
public class BubbleSort { 
    public static void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        int n = arr.length;
        // 外层循环控制排序轮数
        for (int i = 0; i < n - 1; i++) {
            // 优化：如果一轮比较中没有发生交换，说明数组已经有序
            boolean swapped = false;
            // 内层循环控制每轮比较次数，每轮都会将最大的元素“冒泡”到末尾
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 2. 使用封装的 swap 方法
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            // 如果内层循环未发生任何交换，则提前终止排序
            if (!swapped) {
                break;
            }
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
## 8.2 选择排序
**选择排序（Selection Sort）** 是一种基于比较的排序算法。它通过反复从未排序的部分中选择最小（或最大）的元素，并将其与第一个未排序的元素交换，来对数组进行排序。这个过程一直持续到整个数组被排序完成。
该算法的时间复杂度始终为 $O(n²)$，不受输入数据的有序性影响，因此更适合处理小规模数据集。作为一种原地排序算法，它的核心优势在于空间效率极高 —— 仅需常数级别的额外内存空间，无需占用额外的存储资源，这也是其在特定场景下仍具实用价值的关键原因。
![[选择排序.gif]]
```java
public class SelectionSort {
	public static void sort(int[] arr) {
	    if (arr == null || arr.length < 2) {
	        return;
	    }
	    int n = arr.length;
	    // 外层循环控制排序轮数，每次确定一个最小元素的位置
	    for (int i = 0; i < n - 1; i++) {
	        int minIndex = i; 
	        // 内层循环在未排序部分寻找真正的最小值
	        for (int j = i + 1; j < n; j++) {
	            if (arr[j] < arr[minIndex]) {
	                minIndex = j; 
	            }
	        }
	        // 如果最小值不是当前位置，再进行交换
	        if (minIndex != i) {
	            swap(arr, i, minIndex);
	        }
	    }
	}
	
	private static void swap(int[] arr, int i, int j) {
	    int temp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = temp;
	}
}
```
## 8.3 插入排序
**插入排序（Insertion sort）** 是一种简单的排序算法，它通过迭代将未排序列表中的每个元素插入到列表已排序部分中的正确位置。它就像在手中整理扑克牌。你将牌分成两组：已排序的牌和未排序的牌。然后，你从未排序的牌组中拿起一张牌，并将其放到已排序牌组的正确位置。
第一个元素默认是有序区。取下一个未排序元素，从已排序区从右向左比较，找到插入位置。将大于它的元素后移，插入该元素。重复直到全部元素处理完。
![[插入排序.gif]]
```java
public void insertionSort(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	int n = arr.length;
    // 从第二个元素开始，默认第一个元素为已排序
    for (int i = 1; i < n; i++) {
        int current = arr[i]; // 待插入元素
        int j = i - 1;
        // 将大于 current 的元素向后移动
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 找到插入位置，插入 current
        arr[j + 1] = current;
    }
}
```
## 8.4 希尔排序
**希尔排序（Shell Sort）** 是**插入排序的一种改进版本**，也称为**缩小增量排序**。它通过将待排序的列表分成若干子列表，对每个子列表进行插入排序，逐步缩小子列表的间隔，最终完成排序。
![[希尔排序.gif]]
```java
public void shellSort(int[] arr) {
	if (arr == null || arr.length < 2) {
	    return;
	}
	int n = arr.length;
    // 初始步长（间隔）为数组长度的一半，之后逐步减半
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 从 gap 开始，对每个分组进行插入排序
        for (int i = gap; i < n; i++) {
            int current = arr[i];
            int j = i - gap;
            // 在组内进行插入排序
            while (j >= 0 && arr[j] > current) {
                arr[j + gap] = arr[j];
                j -= gap;
            }
            arr[j + gap] = current;
        }
    }
}
```
## 8.5 归并排序
**归并排序（Merge sort）** 是一种流行的排序算法，以其高效性和稳定性而闻名。它遵循分治策略。它的工作原理是递归地将输入数组分成两半，递归地对两半进行排序，最后将它们合并在一起以获得排序后的数组。
其时间复杂度稳定为 $O(n log n)$，不受输入有序程度影响，但需要额外线性空间，即时间复杂度为 $O(n)$，是典型的稳定排序算法。
![[归并排序.gif]]
```java
public class MergeSort {
    public static void sort(int[] array) {
        // 边界条件检查
        if (array == null || array.length < 2) {
            return;
        }
        // 创建一个与原数组等长的临时数组，用于合并操作
        // 在递归开始前一次性创建，可以避免在递归过程中频繁创建和销毁数组，提高效率
        int[] tempArray = new int[array.length];
        // 调用递归排序方法，对整个数组进行排序
        sortRecursive(array, tempArray, 0, array.length - 1);
    }

    private static void sortRecursive(int[] array, int[] tempArray, int left, int right) {
        // 递归终止条件：当子数组只有一个元素或为空时，无需再分割
        if (left >= right) {
            return;
        }

        // 计算中间点，将数组分为两部分
        // 使用 (left + right) >>> 1 或 left + (right - left) / 2 可以防止整数溢出
        int mid = left + ((right - left) >> 1);

        // 递归地对左半部分进行“归”
        sortRecursive(array, tempArray, left, mid);
        // 递归地对右半部分进行“归”
        sortRecursive(array, tempArray, mid + 1, right);

        // 当左右两部分都递归排序完成后，执行“并”操作
        merge(array, tempArray, left, mid, right);
    }

    private static void merge(int[] array, int[] tempArray, int left, int mid, int right) {
        // 初始化三个指针
        int leftPos = left;       // 指向左子数组的起始位置
        int rightPos = mid + 1;   // 指向右子数组的起始位置
        int tempPos = left;       // 指向临时数组的当前填充位置

        // 核心合并逻辑：比较左右子数组的元素，将较小的放入临时数组
        while (leftPos <= mid && rightPos <= right) {
            // 稳定排序：当元素相等时，优先取左子数组的元素，保证其相对位置不变
            if (array[leftPos] <= array[rightPos]) {
                tempArray[tempPos++] = array[leftPos++];
            } else {
                tempArray[tempPos++] = array[rightPos++];
            }
        }

        // 处理剩余元素：如果左子数组还有剩余，将其全部复制到临时数组
        while (leftPos <= mid) {
            tempArray[tempPos++] = array[leftPos++];
        }

        // 处理剩余元素：如果右子数组还有剩余，将其全部复制到临时数组
        // （实际上，这两个 while 循环只会执行其中一个）
        while (rightPos <= right) {
            tempArray[tempPos++] = array[rightPos++];
        }

        // 将临时数组中已排序的部分复制回原数组的对应位置
        // 完成一次合并操作
        for (int i = left; i <= right; i++) {
            array[i] = tempArray[i];
        }
    }
}
```
## 8.6 快速排序
**快速排序（Quick Sort）** 是一种基于分治策略的排序算法，它选择一个元素作为基准，并将给定数组围绕这个基准进行划分，使基准元素在排序后的数组中处于正确的位置。
![[快速排序.gif]]
```java
public class QuickSort {
	public static void sort(int[] arr) {
	    if (arr == null || arr.length < 2) {
	        return;
	    }
	    quickSort(arr, 0, arr.length - 1);
	}
	
	private static void quickSort(int[] arr, int left, int right) {
	    if (left >= right) {
	        return;
	    }
	    int pivotIndex = partition(arr, left, right);
	    quickSort(arr, left, pivotIndex - 1);
	    quickSort(arr, pivotIndex + 1, right);
	}

    private static int partition(int[] arr, int left, int right) {
        // 选择最右侧元素作为基准（可优化为随机选择或三数取中）
        int pivot = arr[right];
        // 初始化小于基准的元素的边界指针
        int i = left;
        
        // 遍历数组，将小于基准的元素交换到左侧区域
        for (int j = left; j < right; j++) {
            if (arr[j] < pivot) {
                // 交换元素，使得i左侧都是小于基准的元素
                swap(arr, i, j);
                i++;
            }
        }
        
        // 将基准元素放到正确的位置（此时i指向第一个大于基准的元素）
        swap(arr, i, right);
        return i; // 返回基准的最终位置
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
## 8.7 堆排序
**堆排序（Heap Sort**）是一种优化的选择排序，它利用堆这种数据结构的特性来进行排序。该算法会反复找到最大（或最小）元素，并将其与最后一个（或第一个）元素交换，并重新构建堆，这个过程会一直重复，直到所有元素都被排序。
![[大顶堆与小顶堆.png]]
![[堆排序.gif]]
```java
public class HeapSort {
    public static void sort(int[] arr) {
        // 边界条件检查
        if (arr == null || arr.length < 2) {
            return;
        }

        int n = arr.length;

        // 1. 构建大顶堆
        // 从最后一个非叶子节点开始，自下而上，自右向左进行调整
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // 2. 排序
        // 逐个将堆顶元素（当前最大值）与数组末尾元素交换
        // 然后调整剩余元素为大顶堆
        for (int i = n - 1; i > 0; i--) {
            // 将当前最大值移动到数组末尾
            swap(arr, 0, i);
            // 调整剩余的 i 个元素，使其重新成为大顶堆
            heapify(arr, i, 0);
        }
    }

    private static void heapify(int[] arr, int heapSize, int rootIndex) {
        int largest = rootIndex;      // 假设根节点是最大的
        int leftChild = 2 * rootIndex + 1;  // 左子节点索引
        int rightChild = 2 * rootIndex + 2; // 右子节点索引

        // 如果左子节点存在且大于当前最大值
        if (leftChild < heapSize && arr[leftChild] > arr[largest]) {
            largest = leftChild;
        }

        // 如果右子节点存在且大于当前最大值
        if (rightChild < heapSize && arr[rightChild] > arr[largest]) {
            largest = rightChild;
        }

        // 如果最大值不是根节点，说明需要交换并继续调整
        if (largest != rootIndex) {
            swap(arr, rootIndex, largest);
            // 递归地调整受影响的子树
            heapify(arr, heapSize, largest);
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
## 8.8 计数排序
**计数排序（Counting Sort）** 是一种非比较类排序算法。当输入值的范围与待排序元素数量相比较小时，它特别高效。计数排序的基本思想是统计输入数组中每个不同元素的频率，并利用这些信息将元素放置到它们正确的排序位置上。
![[计数排序.gif]]
```java
public static void countSort(int[] arr) {
    // 处理空数组或空指针的边界情况
    if (arr == null || arr.length < 2) {
        return;
    }

    // 步骤1：确定值域范围
    // 初始化最大值和最小值为数组第一个元素
    int max = arr[0], min = arr[0];
    // 遍历数组寻找实际的最大最小值
    for (int num : arr) {
        max = Math.max(max, num);  // 更新最大值
        min = Math.min(min, num);  // 更新最小值
    }

    // 计算实际值域范围（最大值与最小值的跨度）
    int range = max - min + 1;
    // 创建计数数组，索引对应实际值偏移量（值域优化）
    int[] count = new int[range];

    // 步骤2：统计元素频率
    // 遍历原始数组，在计数数组中记录每个元素的出现次数
    for (int num : arr) {
        // 将元素值转换为基于最小值的偏移索引
        count[num - min]++;  // 例如元素5在min=3时对应索引2
    }

    // 步骤3：重构排序结果
    int arrayIndex = 0;
    // 遍历计数数组的每个槽位
    for (int i = 0; i < count.length; i++) {
        // 根据计数次数重复元素值
        for (int j = 0; j < count[i]; j++) {
            // 将偏移索引转换回原始值：当前索引i + 最小值min
            arr[arrayIndex++] = i + min;
        }
    }
}
```
## 8.9 桶排序
**桶排序（Bucket Sort）** 是一种分布式排序算法，将元素划分到不同组或桶中的排序技术。这些桶通过均匀分布元素来形成。一旦元素被划分到桶中，可以使用任何其他排序算法对它们进行排序。最后，将排序后的元素按顺序收集在一起。
![[桶排序.gif]]
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public void sort(int[] array) {
	if (array == null || array.length < 2) {
    	return;
    }
    
	// 1. 确定数组的最大值和最小值，以计算桶的范围
	int max = array[0];
	int min = array[0];
	for (int num : array) {
		if (num > max) max = num;
		if (num < min) min = num;
	}

	// 2. 初始化桶
	// 桶的数量可以自定义，这里我们使用数组长度作为桶的数量
	int bucketCount = array.length;
	List<List<Integer>> buckets = new ArrayList<>(bucketCount);
	for (int i = 0; i < bucketCount; i++) {
		buckets.add(new ArrayList<>());
	}

	// 3. 将元素分配到各个桶中
	// 桶的区间大小：(max - min) / bucketCount + 1 (+1可防止桶区间大小为0)
	int bucketSize = (max - min) / bucketCount + 1;
	for (int num : array) {
		// 计算元素应该放入哪个桶
		int bucketIndex = (num - min) / bucketSize;
		buckets.get(bucketIndex).add(num);
	}

	// 4. 对每个桶进行排序，并将结果合并回原数组
	int index = 0;
	for (List<Integer> bucket : buckets) {
		// 如果桶不为空，则进行排序
		if (!bucket.isEmpty()) {
			// 对桶内元素进行排序，这里使用 Java 自带的排序（TimSort）
			// 对于小数据量，插入排序效率更高，可以替换为自定义的 insertionSort
			Collections.sort(bucket);
			// 将排序后的桶内元素依次放回原数组
			for (int num : bucket) {
				array[index++] = num;
			}
		}
	}
}
```
## 8.10 基数排序
**基数排序（Radix Sort）** 是一种线性排序算法（适用于固定长度的数字计数），通过逐位处理元素来对它们进行排序。它是一种对整数或具有固定大小键的字符串的高效排序算法。
![[基数排序.gif]]
```java
/**
 * 基数排序算法的实现类 (LSD)
 * 适用于整数排序，特别是位数较多的整数。
 */
public class RadixSort {
    public void sort(int[] array) {
        // 边界条件检查
        if (array == null || array.length < 2) {
            return;
        }

        // 1. 找出数组中的最大值，以确定需要排序的位数
        int max = array[0];
        for (int num : array) {
            if (num > max) {
                max = num;
            }
        }

        // 2. 从个位开始，对每一位进行排序
        // exp 是指数，1代表个位，10代表十位，100代表百位...
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(array, exp);
        }
    }

    private void countingSortByDigit(int[] array, int exp) {
        int n = array.length;
        int[] output = new int[n];    // 存放排序结果的临时数组
        int[] count = new int[10];     // 计数数组，因为数字是0-9

        // 1. 统计当前位上各数字（0-9）出现的次数
        for (int i = 0; i < n; i++) {
            int digit = (array[i] / exp) % 10;
            count[digit]++;
        }

        // 2. 计算累加和，以确定每个数字在输出数组中的最终位置
        // count[i] 现在表示数字 i 的最终结束位置
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // 3. 从后向前遍历原数组，将元素放入输出数组的正确位置
        // 从后向前遍历是为了保持排序的稳定性
        for (int i = n - 1; i >= 0; i--) {
            int digit = (array[i] / exp) % 10;
            output[count[digit] - 1] = array[i];
            count[digit]--;
        }

        // 4. 将排序好的结果复制回原数组
        System.arraycopy(output, 0, array, 0, n);
    }
}
```
## 8.11 排序算法对比
![[十大排序算法的分类.png]]
![[十大排序算法性能对比1.png]]
![[十大排序算法性能对比2.png]]
![[排序算法选择推荐.png]]

# 九、动态规划
**动态规划**是一种将复杂问题分解为若干相互重叠的子问题，通过保存子问题的解来避免重复计算，从而高效求解最优问题的方法。


🌶**截止至2025年 12 月 3 日**

[^1]: 二叉树是**顺序树**，其左右子树不能颠倒。

[^2]: 由于它的节点紧凑排列，如果**从左到右从上到下**对它的每个节点编号，那么父子节点的索引存在明显的规律。

[^3]: **<v, w>≠<w, v>**

[^4]: **(v, w)=(w v)**

[^5]: 对于E的取值范围
	E 的最小值可以是 0，相当于图结构中只有若干互不相连的节点，这是可以的。
	考虑 E 的最大值，图中的每个节点最多可以有 V−1 条边与其他 V−1 个节点相连，所以最多能有的边数为 E=V(V−1)/2 ≈V^2。

[^6]: 强连通图是弱连通图的 “**特殊情况**”，弱连通图是强连通图的 “**一般情况**”。

[^7]: 邻接表结构**与哈希表中的“链式地址”非常相似**，因此我们也可以采用类似的方法来优化效率。比如当链表较长时，**可以将链表转化为 AVL 树或红黑树**，从而将时间效率从 O(n)优化至 O(logn)；还可以把链表转换为哈希表，从而将时间复杂度降至 O(1)。

[^8]: 集合的特性是: **不允许重复元素**
